/**
 * @Description
 * @Author veritas
 * @Data 2025/3/3 21:20
 */
public class SegementTree {
    /**
     * <pre>
     * 利用线段树 解决 区间最大值
     * 有一个数组 arr = [ 3 , 20 , 11 , 19 , 6 , 2 ]
     *                   1    2    3    4   5   6
     * 数组arr的区间是从1开始的
     * 下面这棵树 表示区间
     *                   [1,6]
     *                ↙        ↘
     *          [1,3]           [4,6]
     *         ↙    ↘             ↙    ↘
     *     [1,2]    [3,3]     [4,5]    [6,6]
     *    ↙   ↘                ↙   ↘
     * [1,1] [2,2]         [4,4] [5,5]
     * 把上面这棵树 变成 完全二叉树
     *                   [1,6]
     *                ↙        ↘
     *          [1,3]            [4,6]
     *         ↙    ↘             ↙    ↘
     *     [1,2]    [3,3]       [4,5]    [6,6]
     *    ↙   ↘     ↙   ↘       ↙   ↘
     * [1,1] [2,2] nill nill [4,4] [5,5]
     * 从上到下 从左到右 给每一个节点编号
     *                       1.[1,6]
     *                ↙                 ↘
     *          2.[1,3]                 3.[4,6]
     *         ↙        ↘                   ↙      ↘
     *    4.[1,2]       5.[3,3]         6.[4,5]     7.[6,6]
     *    ↙     ↘           ↙   ↘          ↙   ↘
     * 8.[1,1] 9.[2,2] 10.nill 11.nill 12.[4,4] 13.[5,5]
     * 根据完全二叉树的特性
     * 对任意节点i
     *  parent = i/2 向下取整
     *  left = 2 * i
     *  right = 2 * i + 1
     *
     *  因为每一个节点 代表了 每个对应区间的最大值 得到一棵树
     *  先得到这棵树的每一个叶子结点对应的区间的最大值
     *  然后逐层求出每一个非叶子结点的对应的区间的最大值 (由下往上)
     *                       1.[1,6]
     *                          20
     *                ↙                    ↘
     *          2.[1,3]                    3.[4,6]
     *             20                          19
     *         ↙        ↘                    ↙      ↘
     *    4.[1,2]       5.[3,3]           6.[4,5]     7.[6,6]
     *       20             11               19            2
     *    ↙     ↘          ↙   ↘            ↙     ↘
     * 8.[1,1] 9.[2,2] 10.nill 11.nill 12.[4,4] 13.[5,5]
     *    3      20                       19       6
     * 这棵树最终变成
     *                       1.[1,6]
     *                          20
     *                ↙                    ↘
     *          2.[1,3]                    3.[4,6]
     *             20                          19
     *         ↙        ↘                    ↙      ↘
     *    4.[1,2]       5.[3,3]           6.[4,5]     7.[6,6]
     *       20             11               19            2
     *    ↙     ↘                         ↙     ↘
     * 8.[1,1] 9.[2,2]               12.[4,4]  13.[5,5]
     *    3      20                       19       6
     * eg: 现在区间查询[2,3]区间上的最大值
     * 从树根开始遍历
     * 1.1 区间[2,3] 与 根节点 1.[1,6] 不完全匹配，向下遍历
     *      区间[2,3] 与 根节点 1.[1,6] 的左孩子 2.[1,3] 有交集 只往左子节点走
     *
     * 2.1 区间[2,3] 与 节点 2.[1,3] 不完全匹配，向下遍历
     *      区间[2,3] 与 节点 2.[1,3] 的左孩子 4.[1,2] 右孩子 5.[3,3] 有交集，左右2个节点都要遍历到
     *      分别 去节点4 查询区间[2,2] 和 去节点5 查询区间[3,3] 最大值
     *
     * 3.1 区间[2,2]与 节点4[1,2] 不完全匹配，向下遍历
     *      区间[2,2] 与 节点4[1,2] 的右孩子 9.[2,2] 有交集 只往右子节点走
     *
     * 4.1 区间[2,2] 与 节点9.[2,2] 完全匹配 => 得到区间[2,2]的最大值=20
     *
     * 3.2 区间[3,3]与 节点5.[3,3] 完全匹配 => 得到区间[3,3]的最大值=11
     *
     * 2.2 区间[2,3] 的最大值 是 [2,2]和[3,3]的最大值 得到 20
     *
     * 1.2 区间[2,3] 的最大值 是 20
     *
     * eg: 现在区间查询[3,5]区间上的最大值
     * 1.1 区间[3,5] 与 根节点 1.[1,6] 不完全匹配，向下遍历
     *     区间[3,5] 与 根节点 1.[1,6] 的左孩子 2.[1,3] 右孩子 3.[4,6] 有交集，左右2个节点都要遍历到
     *     分别 去节点2 查询区间[3,3] 和 去节点3 查询区间[4,5] 最大值
     *
     * 2.1 区间[3,3]与 节点2[1,3] 不完全匹配，向下遍历
     *     区间[3,3] 与 节点2[1,3] 的右孩子 5.[3,3] 有交集 只往右子节点走
     *
     * 3.1 区间[3,3]与 节点5[3,3] 完全匹配 => 得到区间[3,3]的最大值 = 11
     *
     * 2.2 区间[4,5] 与 节点2[4,6] 不完全匹配，向下遍历
     *      区间[4,5] 与 节点2[4,6] 的左孩子 6.[4,5] 有交集 只往左子节点走
     *
     * 3.2 区间[4,5]与 节点5[4,5] 完全匹配 => 得到区间[4,5]的最大值 = 19
     *
     * 1.2 区间[3,3] 和 区间[4,5] 最大值 => 19
     *
     * eg:单点更新 某一个元素
     * 更新arr[2] = 6 原始值 = 20
     * 从根节点开始
     * 位置2 与 根节点1.[1,6] 的 左孩子2.[1,3] 有交集
     * 来到其左孩子 2.[1,3]
     * 位置2 与 节点2.[1,3]的 左孩子4.[1,2] 有交集
     * 来到其左孩子 4.[1,2]
     * 位置2 与 节点4.[1,2]的 右孩子9.[2,2] 有交集
     * 来到其右孩子 9.[2,2]
     * 位置2 与 节点9.[2,2]  完全匹配，因此 修改节点.[2,2]的值 = 6
     * 接下来从底向上 更新其父节点的值
     * 更新节点4.[1,2] = Max(8.[1,1] , 9.[2,2]) = 6
     * 更新节点2.[1,3] = Max(4.[1,2] , 5.[3,3]) = 11
     * 更新节点1.[1,6] = Max(4.[1,3] , 5.[4,9]) = 19
     *
     * 区间更新: 为一个区间内的所有值 加上一个常数
     * </pre>
     */
}
