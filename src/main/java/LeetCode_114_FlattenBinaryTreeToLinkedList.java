/**
 * @Description
 * @Author veritas
 * @Data 2025/3/5 11:48
 */
public class LeetCode_114_FlattenBinaryTreeToLinkedList {
    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode() {
        }

        TreeNode(int val) {
            this.val = val;
        }

        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    /**
     * <pre>
     *           1
     *         /  \
     *        2    3
     *       / \    \
     *      4   5    6
     *     / \
     *    7   8
     *  采用递归自底向上的方法扁平化二叉树，使得每个节点的右指针依次连接形成链表。下面是每个关键步骤的链表形状说明
     *  我们采用递归自底向上的扁平化方法，每个节点的处理步骤为：
     *  先递归扁平化左右子树；
     *  将已扁平化的左子树接到右侧；
     *  找到新右侧链表的尾部，将原右子树接到尾部
     *
     *  Step 1：处理叶子节点
     *  节点 7、8、5、6 均为叶子节点，扁平化后各自构成单节点链表
     *  链表:
     *      7
     *      8
     *      5
     *      6
     *  Step 2：处理节点 4
     *  节点 4 的左右子树：
     *  左子树：节点 7（链表：7）
     *  右子树：节点 8（链表：8）
     *  处理步骤：
     *  保存节点 4 的右子树（节点 8）；
     *  将左子树（节点 7）移到右侧，使节点 4 的右指针指向节点 7，同时置左指针为 null；
     *  遍历新右侧链表（目前只有节点 7），找到尾部（节点 7）；
     *  将保存的原右子树（节点 8）接到尾部节点后。
     *  结果链表（以节点 4 为根）：
     *      4 -> 7 -> 8
     *
     *   Step 3：处理节点 2
     *   节点 2 的左右子树：
     *   左子树：节点 4，经扁平化后为链表 4 -> 7 -> 8
     *   右子树：节点 5，经扁平化后为链表 5
     *   处理步骤：
     *   保存节点 2 的右子树（节点 5）；
     *   将左子树链表 4 -> 7 -> 8 移到右侧，使得节点 2 的右指针指向节点 4，同时将左指针置为 null；
     *   遍历新的右侧链表，从节点 4 开始依次到达尾部，依次经过：4 → 7 → 8；尾部为节点 8；
     *   将保存的原右子树（链表 5）接到尾部节点 8 的右边。
     *   结果链表（以节点 2 为根）：
     *      2 -> 4 -> 7 -> 8 -> 5
     *
     *    Step 4：处理节点 3
     *    节点 3 的左右子树：
     *    左子树：为空
     *    右子树：节点 6，经扁平化后为单节点链表 6
     *    处理步骤：
     *    由于节点 3 的左子树为空，直接保持右子树不变，无需调整。
     *    结果链表（以节点 3 为根）：
     *       3 -> 6
     *
     *    Step 5：处理根节点 1
     *    根节点 1 的左右子树：
     *    左子树：节点 2，经扁平化后为链表 2 -> 4 -> 7 -> 8 -> 5
     *    右子树：节点 3，经扁平化后为链表 3 -> 6
     *    处理步骤：
     *    保存节点 1 的右子树（链表 3 -> 6）；
     *    将左子树链表 2 -> 4 -> 7 -> 8 -> 5 移到右侧，使得节点 1 的右指针指向节点 2，同时将左指针置为 null；
     *    遍历新的右侧链表，从节点 2 开始依次到达尾部：经过节点 2 → 4 → 7 → 8 → 5，尾部为节点 5；
     *    将保存的原右子树（链表 3 -> 6）接到尾部节点 5 的右边。
     *    最终链表形状（以节点 1 为根）：
     *       1 -> 2 -> 4 -> 7 -> 8 -> 5 -> 3 -> 6
     * </pre>
     *
     * @param root
     */
    public void flatten(TreeNode root) {
        /**
         * <pre>
         *           1
         *         /  \
         *        2    3
         *       / \    \
         *      4   5    6
         *     / \
         *    7   8
         *  对于子树
         *      4
         *     / \
         *    7   8
         *  先保存 右子树:8
         *  然后 左子树 7 变成父节点的新的右子树
         *      4
         *       \
         *        7
         *  然后遍历新的右子树到尾节点，并让尾节点的next指向原有的右子树
         *      4
         *       \
         *        7
         *         \
         *          8
         *  对于子树
         *        2
         *       / \
         *      4   5
         *       \
         *        7
         *         \
         *          8
         *  先保存 右子树:5
         *  然后 左子树 4 变成父节点的新的右子树
         *        2
         *         \
         *          4
         *           \
         *            7
         *             \
         *              8
         *  然后遍历新的右子树到尾节点，并让尾节点的next指向原有的右子树
         *        2
         *         \
         *          4
         *           \
         *            7
         *             \
         *              8
         *               \
         *                5
         * 对于子树
         *      3
         *       \
         *        6
         *  先保存 右子树:6
         *  然后 左子树 null 变成父节点的新的右子树
         *  然后遍历新的右子树到尾节点，并让尾节点的next指向原有的右子树
         *      3
         *       \
         *        6
         *  对于子树
         *           1
         *         /  \
         *        2    3
         *         \    \
         *          4    6
         *           \
         *            7
         *             \
         *              8
         *               \
         *                5
         *  先保存 右子树:3
         *  然后 左子树 2 变成父节点的新的右子树
         *           1
         *            \
         *             2
         *              \
         *               4
         *                \
         *                 7
         *                  \
         *                   8
         *                    \
         *                     5
         *  然后遍历新的右子树到尾节点，并让尾节点的next指向原有的右子树
         *           1
         *            \
         *             2
         *              \
         *               4
         *                \
         *                 7
         *                  \
         *                   8
         *                    \
         *                     5
         *                      \
         *                       3
         *                        \
         *                         6
         * </pre>
         */
        // base case: 空树直接返回
        if (root == null) {
            return;
        }

        // 先递归对左右孩子的所在子树执行相同操作
        flatten(root.left);
        flatten(root.right);
        // 递归代码执行完说明左子树 右子树 已经全部变成了链表

        //此时先保存当前节点的右子树(已经是链表了)的头节点
        TreeNode tmp = root.right;

        // 把当前节点的左子树(已经是链表了)的头节点赋值到右节点
        root.right = root.left;
        root.left = null;

        // 从当前节点开始 遍历新的右子树(链表) 遍历到尾节点
        TreeNode current = root;
        while (current.right  != null) {
            //已经变成链表的树 是没有左节点的
            current = current.right;
        }
        // 将之前保存的原右子树连接到尾节点
        current.right = tmp;
    }

}
