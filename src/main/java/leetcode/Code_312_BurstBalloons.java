package leetcode;

/**
 * @Description
 * @Author veritas
 * @Data 2024/8/16 11:13
 * <h1>
 * 范围尝试模型
 * </h1>
 */
public class Code_312_BurstBalloons {
    /**
     * <pre>
     * TODO
     *  拆解问题：
     *      假设你有一个区间 [left, right]，表示从第 left 个气球到第 right 个气球。
     *      现在我们要计算在这个区间内，假设我们最终决定 k 是最后一个被戳破的气球。
     *      那么，假设我们已经先处理了 left 到 k-1 和 k+1 到 right 的区间（即这两个区间内的气球都已经被戳破），最后再戳破 k。
     * TODO
     *  戳破 k 时的得分：
     *      当 k 被戳破时，它的得分为 nums[left-1] * nums[k] * nums[right+1]。
     *      这个得分是基于 k 的左邻居 nums[left-1] 和右邻居 nums[right+1] 的值计算出来的。
     * TODO
     *  对于气球 k 而言，它的左右邻居是 还没有被戳破的最近的气球，不是，真正的k - 1和k + 1
     *      而是这些气球在递归处理过程中剩下的没有被戳破的部分。
     *  因此，递归公式中的 nums[left - 1] 和 nums[right + 1] 确实代表了距离气球 k 最近、但还没有被戳破的气球
     * TODO
     *  为什么说左边和右边的气球都已经被戳破了？
     *  当我们递归处理这个区间时，我们假设在 k 被戳破之前，[left, k-1] 和 [k+1, right] 两部分已经被处理过了
     *      （即在这个递归调用之前，这些区间中的气球已经被戳破）。
     *  因此，k 在被戳破时，它的左邻居是 nums[left-1]，右邻居是 nums[right+1]，而 left 到 k-1 和 k+1 到 right 之间的气球已经不存在了
     * TODO
     *  递归思想的核心：
     *      在递归过程中，我们假设每次处理某个区间时，选择一个气球作为最后一个被戳破的气球，这个气球的左右邻居是尚未被戳破的最近气球 ☆☆☆☆☆☆☆☆☆☆☆☆
     *  eg:
     *  假设 nums = [3, 1, 5, 8]，在两边加上虚拟气球后，我们有 newNums = [1, 3, 1, 5, 8, 1]
     *     1.假设处理区间 [1, 4]（即 nums = [3, 1, 5, 8]），选择气球 i = 2（即 1）作为最后一个戳破的气球。
     *      在 i = 2 被戳破时，
     *              此时它的左右邻居是 nums[1] = 3 和 nums[3] = 5，
     *              所以戳破 2 时获得的硬币数为：nums[1] * nums[2] * nums[3] = 3 * 1 * 5 = 15
     *     2.因此递归会处理剩余的左右两个区间：
     *          2.1.左侧区间 [1, 1]，只剩下 3，它之后被戳破。
     *              选定 i = 1 作为最后一个被戳破的气球。
     *              此时它的左右邻居是 nums[0] = 1 和 nums[2] = 1（虚拟气球和 nums[2] 还没有被戳破，因为我们假设它是最后一个被戳破的气球）
     *          2.2.右侧区间 [3, 4]，剩下 5 和 8，递归处理这两个气球,我们再次假设某个气球是最后一个被戳破的
     *              假设我们选择 i = 4（气球 8）作为最后一个被戳破的气球：
     *              戳破气球 4 时，左右邻居是 nums[3] = 5 和 nums[5] = 1（虚拟气球），所以戳破 4 获得的硬币数为：5 * 8 * 1 = 40
     *              2.2.1.递归会处理剩余的左侧区间[3, 3]
     *                  区间 [3, 3] 只有一个气球 5。它的左右邻居是：
     *                      nums[2] = 1（在戳破之前，这个虚拟气球在左侧，仍未被戳破）
     *                      nums[4] = 8（因为在这个递归子过程的逻辑下，8 是最后一个被戳破的气球，所以 5 戳破时，8 还在）
     *                  所以，戳破气球 5 时，可以获得的硬币数为：硬币数=nums[2]∗nums[3]∗nums[4]=1∗5∗8=40
     *              2.2.2.这个子区间处理完毕，返回的硬币数是 40
     *          2.3.总结整个右子区间 [3, 4] 的硬币数,并向上返回
     *              戳破气球 8 得到 40 个硬币。
     *              然后递归处理剩下的左侧区间 [3, 3]，戳破气球 5 得到 40 个硬币。
     *              因此，总的硬币数为 40（戳破8） + 40（戳破5） = 80
     * eg:
     * arr = [3, 1, 5, 8]
     * newNUms= [1, 3, 1, 5, 8, 1]
     *           0  1  2  3  4  5
     *                                                   (1, 4)
     *                           /               /                            \                     \
     *                  1:3+(2,4)                   15+(1,1)+(3,4)      3:40+(1,2)+(4,4)         4:40+(1,3)
     *              /          \                    /          \          /         \              /                \
     *     2:15+(3,4)        3:40+(2,2)+(4,4)    1:3+(2,1) 3:40+(4,4)  1:3+(2,2)  4:40+(5,4)   1:3+(2,3)         2:15+(1,2)+(3,3)
     *       /     \                /   \                      /         /                  /     \                 /     \
     *  4:40+(3,3)  3:40+(4,4)   2:3+(3,2) 4:40+(5,4)     4:40 +(5,4)  2:3+(3,2)        2:15+(3,3) 3:40+(2,2)   1:3+(2,1) 3:40+(4,3)
     *      /          \                                                                 /        \
     *  4:40+(5,4)  4:40+(5,4)                                                       3:15+(4,3)   2:3+(3,2)
     *    /
     *  15+(4,4)
     *    /
     *  40+(5,4)
     * </pre>
     *
     * @param nums
     * @return
     */
    public int maxCoins(int[] nums) {
        // 在数组的两端各加一个1，便于处理边界情况
        int n = nums.length;
        // 我们首先在数组的两端加上两个虚拟的气球（值为 1），这样在处理时始终可以认为每个气球的左右都有相邻的气球。
        int[] newNums = new int[n + 2];
        newNums[0] = 1;
        newNums[n + 1] = 1;
        System.arraycopy(nums, 0, newNums, 1, n);

        // 计算在新数组的区间[1, n]内戳破气球的最大得分
        return burst(newNums, 1, n);
    }

    private int burst(int[] nums, int left, int right) {
        // 意味着这个区间没有气球可以戳破
        if (left > right) {
            return 0;
        }
        int maxCoins = 0;
        // 尝试在[left, right]区间内最后一个戳破第k个气球
        for (int k = left; k <= right; k++) {
            // 分为左右两部分 + 当前选择的气球得分
            int mid = nums[left - 1] * nums[k] * nums[right + 1];
            // 递归找左部分[left, k-1]的子问题的最优解
            int leftPart = burst(nums, left, k - 1);
            // 递归找右部分[k+1, right]的子问题的最优解
            int rightPart = burst(nums, k + 1, right);

            int coins = mid + leftPart + rightPart;

            maxCoins = Math.max(maxCoins, coins);
        }
        return maxCoins;
    }
}
