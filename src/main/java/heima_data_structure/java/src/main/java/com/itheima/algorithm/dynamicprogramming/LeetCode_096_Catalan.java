package heima_data_structure.java.src.main.java.com.itheima.algorithm.dynamicprogramming;

/**
 * <pre>
 *   卡特兰数
 *   1.有1个节点： 1
 *     能组成二叉搜索树BST的个数 = 1  c(1) = 1
 *   2.有2个节点：1 2
 *     能组成二叉搜索树BST的个数 = 2  c(2) = 2
 *    2.1. 1作为根节点
 *     1
 *       ↘
 *         2
 *    2.2. 2作为根节点
 *          2
 *        ↙
 *      1
 *   3.有3个节点：1 2 3
 *     能组成二叉搜索树BST的个数 = 5  c(3) = 5
 *     3.1. 1作为根节点
 *      1                 1
 *        ↘                 ↘
 *          2                 3
 *             ↘            ↙
 *               3         2
 *     对于1作为根节点 其余的所有节点都在 1的右侧，  两个节点的排列 相当于 c(2) = 2
 *     3.2. 2作为根节点
 *          2
 *       ↙    ↘
 *      1      3
 *     对于2作为根节点 其余的节点在两侧  相当于 c(1) = 1
 *     3.3. 3作为根节点
 *             3          3
 *           ↙          ↙
 *         2          1
 *       ↙              ↘
 *     1                  2
 *     对于3作为根节点 其余的所有节点都在 3的左侧，  两个节点的排列 相当于 c(2) = 2
 *   4.有4个节点：1 2 3 4
 *     能组成二叉搜索树BST的个数 = 14    c(4) = 14
 *     4.1. 1作为根节点
 *      1                 1
 *        ↘                 ↘
 *          2                 2
 *             ↘                ↘
 *               4                3
 *             ↙                    ↘
 *          3                         4
 *
 *           1                  1
 *             ↘                  ↘
 *               4                  4
 *             ↙                  ↙
 *           2                  3
 *             ↘              ↙
 *               3          2
 *
 *        1
 *          ↘
 *            3
 *          ↙    ↘
 *        2        4
 *     对于1作为根节点 ，其余所有节点都 > 1 ,那么3个节点的排列组合 相当于 c(3) = 5
 *     4.2. 2作为根节点
 *          2                   2
 *       ↙     ↘             ↙     ↘
 *      1        4         1         3
 *             ↙                       ↘
 *           3                           4
 *     对于2作为根节点 ，其左侧节点一定是1，不会有变化
 *     其余所有节点都 > 2 ,那么2个节点的排列组合 相当于 c(2) = 2
 *     4.3. 3作为根节点
 *           3                    3
 *         ↙    ↘              ↙     ↘
 *       2        4          1        4
 *     ↙                       ↘
 *    1                           2
 *     对于3作为根节点 ，其右侧节点一定是4，不会有变化
 *     其余所有节点都 < 2 ,那么2个节点的排列组合 相当于 c(2) = 2
 *     4.4. 4作为根节点
 *               4                 4
 *             ↙                 ↙
 *          1                 1
 *             ↘                ↘
 *               3                2
 *             ↙                    ↘
 *          2                         3
 *
 *               4                   4
 *             ↙                   ↙
 *          3                    3
 *             ↘               ↙
 *               1           2
 *             ↙           ↙
 *          2             1
 *
 *                4
 *              ↙
 *            2
 *          ↙    ↘
 *        1        3
 *      对于4作为根节点 ，其余所有节点都 < 4 ,那么3个节点的排列组合 相当于 c(3) = 5
 *   5.有5个节点：1 2 3 4 5
 *     能组成二叉搜索树BST的个数 = 42    c(5) = 42
 *    5.1. 1作为根节点
 *          1
 *       ↙     ↘
 *     c(0)   c(4)
 *     意思表示：
 *       比1小的 有0个数 ，0个数的排列组合 = C(0) = 1
 *       比1大的 有4个数 ，4个数的排列组合 = C(4)
 *    5.2. 2作为根节点
 *          2
 *       ↙     ↘
 *     c(1)   c(3)
 *     意思表示：
 *       比2小的 有1个数 ，1个数的排列组合 = C(1)
 *       比2大的 有3个数 ，3个数的排列组合 = C(3)
 *    5.3. 3作为根节点
 *          2
 *       ↙     ↘
 *     c(2)   c(2)
 *     意思表示：
 *       比3小的 有2个数 ，2个数的排列组合 = C(2)
 *       比3大的 有2个数 ，2个数的排列组合 = C(2)
 *    5.4. 4作为根节点
 *          2
 *       ↙     ↘
 *     c(2)   c(2)
 *     意思表示：
 *       比4小的 有3个数 ，3个数的排列组合 = C(3)
 *       比4大的 有1个数 ，1个数的排列组合 = C(1)
 *    5.1. 1作为根节点
 *          1
 *       ↙     ↘
 *     c(0)   c(4)
 *     意思表示：
 *       比5小的 有4个数 ，4个数的排列组合 = C(4)
 *       比5大的 有0个数 ，0个数的排列组合 = C(0) = 1
 *    ===> C(0) * C(4) +   C(1) * C(3) +  C(2) * C(2) +  C(3) * C(1) + C(4) * C(0)
 * </pre>
 */
public class LeetCode_096_Catalan {
    public static void main(String[] args) {
        System.out.println(catalan(6));
    }

    static int catalan(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int j = 2; j < n + 1; j++) {
            for (int i = 0; i < j; i++) { // 第j个卡特兰数的拆分
//                System.out.printf("(%d,%d)\t", i, j - 1 - i);
                dp[j] += dp[i] * dp[j - 1 - i];
            }
//            System.out.println();
//            System.out.println(Arrays.toString(dp));
        }

        return dp[n];
    }
}
