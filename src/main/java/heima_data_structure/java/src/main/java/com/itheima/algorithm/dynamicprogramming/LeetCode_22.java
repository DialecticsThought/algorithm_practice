package heima_data_structure.java.src.main.java.com.itheima.algorithm.dynamicprogramming;



import java.util.ArrayList;
import java.util.List;

/**
 * <h3>括号生成</h3>
 */
public class LeetCode_22 {
    /**
     * <pre>
     *   catalan数 ☆☆☆☆☆☆☆☆☆☆☆☆☆
     *     数字 n 代表 生成括号的对数 请设计一个函数 用于能欧生成所有可能的并且有效的括号组合
     *     有效括号 ()
     *     无效括号 )(
     *     1.有1对括号 n = 1   c(1) = 1
     *       ( )
     *     2.有2对括号 n = 2   c(2) = 2
     *       ( ) ( )
     *       ( ( ) )
     *      分析套路:分析某一对括号 ，让该括号内不包含其他括号 ，让该括号内包含另1对括号 ，让该括号内包含另2对括号 ....
     *          现在有一对括号:
     *          (  )
     *          ˉ  ˉ
     *          1.该括号内部不包含其他对括号: 2种情况
     *              被分析的括号内部包含了 0对其他括号， 剩余括号 个数 : 1
     *              (   )  (   )
     *              ˉ  ˉ   _  _
     *              被分析的括号内部包含了 1对其他括号， 剩余括号 个数 : 0
     *              (  (  )  )
     *              _  ˉ  ˉ  _
     *     3.有3对括号 n = 3
     *          现在有一对括号:
     *          (  )
     *          ˉ  ˉ
     *          1.该括号内部不包含其他对括号: 2种情况
     *              被分析的括号内部包含了 0对其他括号， 剩余括号 个数 : 2
     *              被分析的括号 所包围的括号的排列组合 = c(0)
     *              被分析的括号 没有包围的括号(也就是剩余括号)的排列组合 = c(2)
     *              (  (  )  )  (  )
     *              _  ˉ  ˉ  _
     *              (  )  (  )   (  )
     *              ˉ  ˉ  _  _
     *
     *                     跨度1
     *              包含  ↙     ↘  平级
     *               c(0)       c(2)
     *              被分析的括号对 里面有 0 个括号
     *              被分析的括号对 平级的 有 2 个括号
     *
     *          2.该括号内部包含1对其他括号: 1种情况
     *               被分析的括号内部包含了 1对其他括号， 剩余括号 (或者称之为平级括号)个数 : 1
     *               被分析的括号 所包围的括号的排列组合 = c(1)
     *               被分析的括号 没有包围的括号(也就是剩余括号)的排列组合 = c(1)
     *              (  (  )  )  (  )
     *              ˉ  _  _  ˉ
     *
     *                     跨度2
     *              包含  ↙     ↘  平级
     *               c(1)       c(2)
     *              被分析的括号对 里面有 1 个括号
     *              被分析的括号对 平级的 有 1 个括号
     *
     *          3.该括号内部包含2对其他括号: 1种情况
     *              被分析的括号内部包含了 2对其他括号， 剩余括号 个数 : 0
     *              被分析的括号 和他平级的其他对括号是没有了
     *              被分析的括号 所包围的括号的排列组合 = c(2)
     *              被分析的括号 没有包围的括号(也就是剩余括号)的排列组合 = c(0)
     *              (  (  (  )  )  )
     *              ˉ  -  _  _  -  ˉ
     *              (  (  )  (  )  )
     *              ˉ  _  _  -  -  ˉ
     *
     *                     跨度3
     *              包含  ↙     ↘  平级
     *               c(2)       c(0)
     *              被分析的括号对 里面有 2 个括号
     *              被分析的括号对 平级的 有 0 个括号
     *
     *     4.有3对括号 n = 4
     *             跨度1
     *      包含  ↙     ↘  平级
     *         c(0)    c(3)
     *      被分析的括号对 里面有 0 个括号
     *      和 被分析的括号对 平级的 有 3 个括号
     *             跨度2
     *      包含  ↙     ↘  平级
     *         c(1)    c(2)
     *      被分析的括号对 里面有 1 个括号
     *      和 被分析的括号对 平级的 有 2 个括号
     *             跨度3
     *      包含  ↙     ↘  平级
     *         c(2)    c(1)
     *      被分析的括号对 里面有 2 个括号
     *      和 被分析的括号对 平级的 有 1 个括号
     *             跨度4
     *      包含  ↙     ↘  平级
     *         c(3)    c(0)
     *      被分析的括号对 里面有 3 个括号
     *      和 被分析的括号对 平级的 有 0 个括号
     *      c(0) * c(3) + c(1) * c(2) +  c(2) * c(1) +  c(3) * c(0)
     * </pre>
     * @param n
     * @return
     */
    public List<String> generateParenthesis(int n) {
        ArrayList<String>[] dp = new ArrayList[n + 1];
        dp[0] = new ArrayList<>(List.of("")); // ""  0 个括号对
        dp[1] = new ArrayList<>(List.of("()")); // () 1 个括号对
        // dp[2] = ()(), (())
        // dp[3] = ()()(), ()(()), (())(), (()()), ((()))
        // 外层循环 j 负责逐步计算每个卡特兰数 dp[j]
        // 外层循环是因为要求 dp[j] j的范围: 2 -> n， 最终要得到dp[n]
        for (int j = 2; j < n + 1; j++) {
            // 内层循环 i 负责将当前 j 拆分成左右两部分 dp[i] * dp[j-1-i]，通过所有的组合来求得当前 j 的卡特兰数
            // 第j个卡特兰数的拆分 ，用dp[i] * dp[j-1-i] 来拆分 j
            // i的范围: 0 -> j-1
            // 初始化 dp [j]
            dp[j] = new ArrayList<>();

            for (int i = 0; i < j; i++) {
                // i 对应的集合是内层要嵌套的括号, j - 1 - i 对应的集合是平级要拼接的括号
                System.out.printf("(%d,%d)\t", i, j - 1 - i);
//                dp[j] += dp[i] * dp[j - 1 - i];
                for (String k1 : dp[i]) { // ()(), (())
                    for (String k2 : dp[j - 1 - i]) { // ""
                        // ()()()
                        // ()(())
                        // (())()
                        // (()())
                        // ((()))
                        dp[j].add("(" + k1 + ")" + k2);
                    }
                }
            }
            System.out.println();
        }
//        System.out.println(dp[n]);
        return dp[n];
    }

    public static void main(String[] args) {
        LeetCode_22 code = new LeetCode_22();
        System.out.println(code.generateParenthesis(3));
    }
}

