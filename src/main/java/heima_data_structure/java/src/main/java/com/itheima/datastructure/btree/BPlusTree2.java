package heima_data_structure.java.src.main.java.com.itheima.datastructure.btree;

import java.util.ArrayList;
import java.util.List;

/**
 * <pre>
 * 对于B+树而言，节点分成 leaf节点，internal内部节点，root节点
 *
 * eg：
 * 设 p = 3  and  pLeaf = 2
 * 叶子节点最多能放2个键值，但现在要插入第3个键值，这个节点就需要分裂
 * 分裂过程
 * 假设有一个满的节点（比如现在要插入的叶子节点已经有了 pLeaf=2，但需要插入第3个键值），我们称这个节点为“第一个节点”
 * 在分裂时，B+树将该节点中的键值和指针分成两部分，形成两个节点。这里的“第二个节点”就是通过分裂产生的新节点
 * “一半”的意思是，分裂时，原节点中的键值和指针被尽量平均分配给两个节点。
 *      例如，如果原节点中有3个键值，那么分裂后，通常第一个节点保留1个键值，第二个节点保留2个键值
 *
 *  设 p = 3  and  pLeaf = 2
 *  p=3: 表示内部节点（非叶子节点）最多可以有3个指针（即最多可以有3个子节点）。
 *      这意味着该节点可以包含最多2个键值（分隔3个子节点的键值）。
 *  pLeaf=2: 表示叶子节点最多可以包含2个键值。叶子节点存储实际的数据值或数据指针，而在B+树中，所有数据都保存在叶子节点中
 *  简而言之：
 *      内部节点的最大分支度为3，即每个内部节点最多有3个子节点。
 *      叶子节点最多可以存储2个键值
 *
 *  标准
 *  每一个key的左侧指针指向的节点的所有key < 当前key
 *  每一个key的右侧指针指向的节点的所有key >= 当前key
 *
 *  B+分裂规则:
 * TODO
 *  1. 叶子节点的分裂规则
 *  B+树的叶子节点存储的是实际数据，且这些数据是按顺序排列的。
 *  当插入一个新的键值对时，如果叶子节点已经满了（节点的度数已达到最大），就需要进行分裂。
 *  规则：
 *  确定中间值：如果叶子节点已满，则找到其中的中间值（通常是中间位置的值），把叶子节点分为左右两部分。
 *  中间值上升到父节点：将中间值上升到父节点，使得父节点作为这个叶子节点分裂的“路标”，用来区分左右两个新叶子节点的范围。
 *  叶子节点指针的调整：分裂后的两个叶子节点会通过链表连接，保持所有叶子节点之间的顺序（这是B+树的特点，所有叶子节点通过链表相连）。
 *  例子：
 *  假设度数为3的B+树叶子节点存储 [3, 5, 8]，插入9后节点变满：
 *  找到中间值8，分裂成 [3, 5] 和 [9] 两个叶子节点。
 *  中间值8上升到父节点，父节点指示范围。
 *  分裂后的叶子节点通过链表连接，保持顺序。
 * TODO
 *  2. 内部节点的分裂规则
 *  内部节点（非叶子节点）存储的是索引值（也就是各子节点的“分界值”）。
 *  内部节点的分裂规则类似于叶子节点，但内部节点存储的值仅用于索引，而不包含实际的数据。
 *  因此，分裂的操作更多是调整树的结构。
 *  规则：
 *  找到中间值：如果内部节点已满，则找到中间的索引值，将该节点分裂为两个节点。
 *  中间值上升：将中间的索引值上升到父节点。
 *  不保留中间值：与叶子节点不同，内部节点的分裂不会保留中间值。该中间值一旦上升到父节点，便充当新的“路标”，不再在原子节点中存在。
 *
 * TODO
 *  3. 根节点的分裂规则
 *  当根节点也变满时，B+树的高度会增加，因为根节点需要分裂，并且会生成新的根节点。
 *  根节点的分裂规则与内部节点类似，但它的分裂会导致树的层数增加。
 *  规则：
 *  找到中间值：同样找到中间值，分裂根节点。
 *  中间值成为新根节点：不同于内部节点的分裂，根节点分裂后，中间值会上升成为新的根节点，导致树的层数增加。
 *  左右子树形成：根节点分裂后会形成两个子节点，这两个子节点的范围分别由新根节点的中间值分界。
 *  例子：
 *  假设根节点是 [5, 10, 15]，插入12后需要分裂：
 *  找到中间值10，分裂成两个子节点：左节点 [5] 和右节点 [12, 15]。
 *  中间值10上升成为新的根节点，树的层数增加。
 * TODO
 *  1. 奇数节点数量的分裂
 *  如果节点中的键值数量是奇数，那么当这个节点被分裂时，通常会选择中间位置的键值进行提升。
 *  分裂后，中间键值不会留在原来的两个子节点中，而是提升到父节点，剩余的键值平均分配到两个子节点中
 *  假设一个叶子节点有 3 个键值 [1, 5, 8]，现在需要分裂：
 *  中间键值是 5
 *  2. 偶数节点数量的分裂
 *  如果节点中的键值数量是偶数，那么中间没有一个明确的“中间键值”，
 *  在这种情况下，分裂时可以选择靠近中间的一个键值进行提升。通常的策略是：
 *  提升靠中间偏右的键值（即分裂后的右半部分的第一个键值）。
 *  分裂后，提升的键值不会留在原来的两个子节点中，而是提升到父节点
 *  一个叶子节点有 4 个键值 [1, 3, 5, 8]，现在需要分裂：
 *  在这个例子中，5 作为提升的中间键值
 *
 *  B+插入规则:
 * TODO
 *  1. 叶子节点的插入操作
 *  叶子节点存储实际的数据值（键值对），当我们进行插入操作时，首先会查找到正确的叶子节点。
 *  如果叶子节点没有满，插入操作就相对简单；如果叶子节点已满，就需要分裂。
 *  步骤：
 *  查找插入位置：根据B+树的查找特性，找到应该插入的叶子节点。
 *  如果树的层数大于1，首先从根节点出发，逐层根据索引值找到相应的叶子节点。
 *  插入元素：将新元素插入到叶子节点的正确位置，保证叶子节点内部数据的有序性。
 *  处理叶子节点满的情况：
 *  如果插入后叶子节点没有满，则插入操作完成。
 *  如果叶子节点满了（即包含的元素个数等于最大度数），就需要进行分裂：
 *  找到叶子节点的中间值。
 *  将叶子节点分裂为两个节点，左节点包含比中间值小的元素，右节点包含比中间值大的元素。
 *  将中间值上升到父节点，作为新分界点。
 *  保持叶子节点的链表指针更新，使叶子节点保持按顺序相连。
 * TODO
 *  2. 内部节点的插入操作
 *  内部节点（非叶子节点）只存储索引值，用来指引搜索的方向。
 *  当内部节点满时，也需要进行分裂。内部节点的插入操作与叶子节点的操作类似，但它只存储索引值，不包含具体的数据，因此处理稍有不同。
 *  步骤：
 *  查找插入位置：从根节点开始，根据索引值找到应该插入的叶子节点，逐层遍历内部节点。
 *  插入中间值到父节点：如果叶子节点分裂了，中间值需要上升到父节点，此时父节点相当于接收一个新的索引值。
 *  处理内部节点满的情况：
 *  如果父节点没有满，则将中间值插入父节点即可。
 *  如果父节点已满（存储的索引值达到了最大度数），则需要对父节点进行分裂：
 *  找到中间值，分裂父节点为左右两个子节点。
 *  中间值继续上升到上层节点，形成新的分界点。
 * TODO
 *  3. 根节点的插入操作
 *  当根节点执行插入操作时，如果根节点没有满，操作较为简单；
 *  如果根节点满了，插入操作会导致树的高度增加，并生成新的根节点。
 *  这是唯一一种导致树高度增加的插入情况。
 *  步骤：
 *  插入元素：根节点作为特殊的内部节点，插入索引值或接收子节点分裂上升的中间值。
 *  处理根节点满的情况：
 *  如果根节点没有满，插入索引值后操作完成。
 *  如果根节点已满（即包含的索引值达到了最大度数），则根节点需要分裂：
 *  找到根节点的中间值，将其上升到新根节点，分裂根节点为两个子节点。
 *  形成新的根节点，并使树的层数增加。
 *  新根节点只有一个值，它有两个子节点，分别是分裂后的左右节点。
 * TODO
 *  4. 加入操作的总结
 *  叶子节点的插入：
 *  查找到合适的叶子节点，将新元素插入保持顺序。
 *  叶子节点满时进行分裂，中间值上升到父节点。
 *  内部节点的插入：
 *  内部节点负责存储索引值，如果下层节点分裂，中间值上升到父节点。
 *  内部节点满时进行分裂，中间值上升到父节点，不在原节点保留。
 *  根节点的插入：
 *  根节点插入时，根节点满了会导致根节点分裂，树的高度增加。
 *  新根节点上升，中间值成为新的根，树的层数增加。
 *  TODO
 *   5. 插入操作整体流程:
 *   插入操作的整体流程可以归纳为以下几点：
 *   查找插入位置：从根节点开始，依次找到合适的子节点或叶子节点。
 *   插入新元素：如果目标节点没有满，直接插入；否则进行分裂。
 *   处理节点分裂：分裂后的中间值上升到父节点，父节点接收中间值。
 *   递归处理父节点的分裂：如果父节点也满了，继续分裂，直到根节点为止。
 *   根节点分裂时树的高度增加：如果根节点满了，分裂根节点，增加树的高度
 *
 * TODO
 *  eg：
 *  依次 插入 8 5 1 7 3 12 9 6
 *  1.插入8
 *   [8]
 *  2.插入5
 *   [ 5 | 8 ]
 *  3.插入1
 *  变成了[ 1 | 5 | 8 ]
 *  出现溢出，需要分裂节点[ 1 | 5 | 8 ]
 *  利用到 中间key向上
 *  该中间key的左侧指针指向的节点的所有key < 中间key
 *  该中间key的右侧指针指向的节点的所有key >= 当前key
 *  分裂变成
 *  [ 1 |   ] [ 5 | 8 ]
 *  最终
 *        [ 5 |   ]
 *       ↙     ↘
 *  [ 1 |   ] -> [ 5 | 8 ]
 *  4.插入7
 *  变成了
 *        [ 5 |   ]
 *       ↙     ↘
 *  [ 1 |   ] -> [ 5 | 7 | 8 ]
 *  出现溢出，需要分裂节点[ 5 | 7 | 8 ]
 *  利用到 中间key向上
 *  该中间key的左侧指针指向的节点的所有key < 中间key
 *  该中间key的右侧指针指向的节点的所有key >= 当前key
 *  分裂变成
 *  [ 5 |   ] [ 7 | 8 ]
 *  最终
 *              [ 5 | 7 ]
 *        ↙         ↓       ↘
 *  [ 1 |   ] -> [ 5 |   ] -> [ 7 | 8 ]
 *  5.插入3
 *              [ 5 | 7 ]
 *        ↙         ↓       ↘
 *  [ 1 | 3 ] -> [ 5 |   ] -> [ 7 | 8 ]
 *  6.插入12
 *              [ 5 | 7 ]
 *        ↙         ↓       ↘
 *  [ 1 | 3 ] -> [ 5 |   ] -> [ 7 | 8 | 12 ]
 *  出现溢出，需要分裂节点[ 7 | 8 | 12 ]
 *  利用到 中间key向上
 *  该中间key的左侧指针指向的节点的所有key < 中间key
 *  该中间key的右侧指针指向的节点的所有key >= 当前key
 *  分裂变成
 *  [ 7 |  ] [8 | 12 ]
 *  变成了
 *              [ 5 | 7 | 8 ]
 *        ↙         ↓       ↘
 *  [ 1 | 3 ] -> [ 5 |   ] -> [ 7 |  ] -> [8 | 12 ]
 *  出现溢出，需要分裂节点[ 5 | 7 | 8 ]
 *  利用到 中间key向上
 *  该中间key的左侧指针指向的节点的所有key < 中间key
 *  该中间key的右侧指针指向的节点的所有key >= 当前key
 *  分裂变成
 *  [ 5 |   ] [ 7 | 8 ]
 *  最终
 *                       [ 7 |   ]
 *                    ↙           ↘
 *              [ 5 |   ]         [ 8 |  ]
 *           ↙      ↓           ↙      ↘
 *  [ 1 | 3 ] -> [ 5 |   ] -> [ 7 |  ] -> [8 | 12 ]
 *  7.插入9
 *                       [ 7 |   ]
 *                    ↙           ↘
 *              [ 5 |   ]         [ 8 |  ]
 *           ↙      ↓           ↙      ↘
 *  [ 1 | 3 ] -> [ 5 |   ] -> [ 7 |  ] -> [8 | 9 | 12 ]
 *  出现溢出，需要分裂节点[8 | 9 | 12 ]
 *  利用到 中间key向上
 *  该中间key的左侧指针指向的节点的所有key < 中间key
 *  该中间key的右侧指针指向的节点的所有key >= 当前key
 *  分裂变成
 *  [ 8 |  ] [9 | 12 ]
 *  最终
 *                       [ 7 |   ]
 *                    ↙           ↘
 *              [ 5 |   ]               [ 8 | 9 ]
 *           ↙      ↓             ↙         ↓         ↘
 *  [ 1 | 3 ] -> [ 5 |   ] -> [ 7 |  ] ->  [ 8 |  ] -> [9 | 12 ]
 *  8.插入6
 *                       [ 7 |   ]
 *                    ↙           ↘
 *              [ 5 |   ]               [ 8 | 9 ]
 *           ↙      ↓             ↙         ↓         ↘
 *  [ 1 | 3 ] -> [ 5 | 6 ] -> [ 7 |  ] ->  [ 8 |  ] -> [9 | 12 ]
 *
 * TODO
 *  借位重分配（Redistribution）
 *      重分配（借位）是指当某个节点的元素数小于最小度数时，可以尝试从相邻的兄弟节点借取元素以恢复平衡。
 *      重分配在同一层次的兄弟节点之间进行，操作方式如下：
 *  规则：
 *      如果一个节点的元素数小于最小度数，则从其相邻兄弟节点中借一个元素。
 *      借位时，父节点的索引值将会更新，以反映节点之间元素的重新分配。
 *  步骤：
 *      1.检查兄弟节点：首先检查该节点的左右兄弟节点，看看是否有兄弟节点可以借一个元素。
 *          兄弟节点的元素数必须大于最小度数才可以进行借位操作。
 *      2.借位：从相邻的兄弟节点借一个元素，将这个元素下移到当前节点中。
 *      3.更新父节点的索引值：为了保证父节点中的索引值依然正确，必须更新父节点中的索引值，使其反映新的节点边界。
 *  例子：
 *      假设叶子节点 [2] 需要删除1，而其兄弟节点是 [4, 5]：
 *          1.[4, 5] 兄弟节点可以借一个元素，因此我们从 [4, 5] 中借4。
 *          2.删除后叶子节点变为 [2, 4]，父节点中原来索引值4需要更新为5，表示新的节点边界。
 *
 * TODO
 *  节点合并（Merge）
 *      如果借位无法使节点恢复平衡（例如相邻的兄弟节点元素数也不满足最小度数），那么就需要进行合并操作。
 *      合并操作会将两个兄弟节点合并为一个节点，并更新父节点的索引值。
 *      合并操作不仅发生在叶子节点，也可能影响到内部节点。
 *  规则：
 *      1.当节点无法通过借位恢复平衡时，合并该节点与相邻的兄弟节点。
 *      2.合并操作会将父节点中的相应索引值删除或下移到合并后的节点中。
 *  步骤：
 *      1.检查兄弟节点：选择与当前节点相邻的兄弟节点，进行合并操作。
 *      2.合并节点：将当前节点与兄弟节点的元素合并到一个节点中。
 *      3.更新父节点：父节点中的索引值会被删除或下移到合并后的节点中。父节点可能由于删除一个索引值而变得不平衡，需要继续递归处理父节点。
 *      4.处理根节点：如果根节点被合并，且根节点的元素数变为0，则树的高度将会降低（即删除后的树的层次减少）。
 *  例子：
 *      假设度数为3的B+树，叶子节点 [3] 和它的右兄弟 [6, 7]。如果 [3] 删除后需要合并：
 *          1.合并后形成新的叶子节点 [3, 6, 7]。
 *          2.父节点中原来的分界点6将被删除或下移。
 *  TODO
 *   对于叶子节点中key的删除
 *     case1: 删除还有富余：
 *            删除之后节点的key的个数 > ⌈m/2⌉ - 1 删除操作结束
 *     case2: 删除没有富余，但是兄弟节点还有富余：
 *            1.兄弟节点的key有富余(> ⌈m/2⌉ - 1) 向兄弟节点借一个记录(key),
 *            2.替换父节点的某一个key
 *            例如 删除 15
 *            兄弟是同一个父亲,
 *            向兄弟借完一个记录(key)之后，兄弟还是满足> ⌈m/2⌉ - 1
 *     case3: 兄弟节点也不富裕，合并兄弟叶子结点：
 *            即兄弟节点合并成一个新的叶子结点，
 *            并删除父节点中的key,（针对父节点 这个非叶子结点的删除，可以看下面流程图）
 *            解释:当叶子节点和兄弟节点合并后，叶子节点所在的层次得到了修复，
 *                  但此时父节点中的关键字减少了一个（因为父节点用于分隔合并节点的关键字被删除了)
 *     叶子节点中key的删除的流程图
 *     1.这里定义的规则中是先判断左兄弟节点是否有富余，再判断右兄弟节点是否有富余 其实都可以
 *     2.合并时，优先和左兄弟合并
 *          原因：为了保持树的顺序。在合并时，左兄弟的关键字一般是较小的一方，这有利于保持节点之间的顺序关系
 *          如果合并时左兄弟不存在或者策略要求右兄弟优先，也可以选择与右兄弟合并
 *          总体而言，合并操作的结果不受选择哪一侧兄弟的影响，但优先左兄弟是常见的做法
 *                                                   开始
 *                                                    |
 *                                   判断被删除的key的所处节点是否是父节点的唯一孩子
 *                                                    |
 *                                 <———————————— 是 —————— 否 ———————————————>
 *                               |                                           |
 *                            删除该叶子结点中的key                  判断：当前节点是根节点吗？
 *                               |                                           |
 *                               V                                <————— 是 —————— 否 —————>
 *           判断：删除后该叶子节点 key 数量 > ⌈m/2⌉ - 1 ?           |                         |
 *                               |                       树可能被清空     父节点 key 下移，当前节点提升为根节点
 *      <————————————————— 是 —————— 否 —————————————>
 *     |                                              |
 *     |                                     判断是否有左兄弟
 *     |                                              |
 *     |                                   <————— 是 —————— 否 ——————>
 *     |                                   |                          |
 *     |                   判断：左兄弟节点是否有富余(> ⌈m/2⌉ - 1)?       |  走到这里一定有右兄弟，因为没有左右兄弟的情况上面分析了
 *     |                                   |                          |
 *     |                   <————————— 是 —————— 否 ——————————————————> |
 *     |                   |                                          |
 *     |                   |                                          |
 *     |          向左兄弟节点借一个 key                   判断：右兄弟节点是否有富余(> ⌈m/2⌉ - 1)?
 *     |                   |                                          |
 *     |           父节点 key 会变化               <———————————— 是 —————— 否 ———————————>
 *     |   父节点的 key 更新为左兄弟原始的最大 key   |                                      |
 *     |                   |                     |                                      |
 *     |                   |             向右兄弟节点借一个 key               当前叶子节点与左兄弟兄弟节点合并
 *     |                   |                     |                                      |
 *     |                   |                 父节点 key 会变化                       删除父节点中的 key(子节点数量变少了)
 *     |                   |      父节点的 key 更新为右兄弟新的最小 key                     |
 *     |                   |                     |                            判断：父节点是根节点？
 *     |                   |                     |                                      |
 *     |                   |                     |                   <———————————— 是 —————— 否 ————————————>
 *     |                   |                     |                  |                                       |
 *     |                   |                     |              树高度降低                针对父节点这个非叶子节点继续删除的流程，请查看下面讲解
 *     |                   |                     |                  |                                        |
 *     |                   |                     |            子节点提升为根节点                               |
 *     |                   |                     |                  |                                        |
 *     |                   |                     |                  |                                        |
 *     —————————————————————————————————> 删除操作结束 <———————————————————————————————————————————————————————
 *
 *  TODO
 *     针对判断 被删除的key的所处节点是否是父节点的唯一孩子 = true的案例
 *          eg1: 树被清空
 *               max degree = 3 的 B+ 树，它只有一个节点，这个节点同时充当根节点和叶子节点。
 *               在这个例子中，节点的最小关键字数为 ⌈m/2⌉ - 1 = 1
 *               [5, 10]
 *                1.删除 key = 5。
 *                       删除 key = 5 之后：
 *                           节点中的剩余 key 只有一个，即 [10]。
 *                           当前节点的 key 数量 > ⌈m/2⌉ - 1（即剩余一个 key），因此它仍然满足 B+ 树的要求，不需要合并或借用操作
 *                 2.删除 key = 10
 *                       删除 key = 10 之后：
 *                           现在根节点（也是叶子节点）变为空节点，树中没有任何 key 了。
 *                           当前节点是根节点，并且这个根节点已经没有 key，这时树会变为空树
 *           eg2: 高度降低
 *                max degree = 3 依次插入 10 20 30 得到
 *                     [20]
 *                    /    \
 *                 [10]     [30]
 *               1.删除 key = 20
 *                   删除 key = 20 之后：
 *                       删除根节点的 key 后，根节点变为空节点，没有任何 key
 *               处理步骤：
 *                   根节点没有 key：因为根节点现在已经没有 key，无法继续作为根节点，我们需要将子节点提升为新的根节点。
 *                   子节点提升为新的根节点：现在，左子节点 [10] 和右子节点 [30] 直接成为新的根节点，树的高度降低。
 *           eg3: 父节点 key 下移，当前节点提升为根节点
 *               max degree = 3 的 B+ 树
 *                        [20]
 *                       /    \
 *                  [10, 15]  [25, 30]
 *                1.删除 key = 10。
 *                       删除 key = 10 之后：
 *                           左子节点变成：[15]。
 *                           这时，左子节点的 key 数量仍然满足条件（key 数量 ≥ ⌈m/2⌉ - 1，即 1 个 key），所以不需要进一步处理
 *                2.删除 key = 15。
 *                       删除 key = 15 之后：
 *                          左子节点变为空节点 []，没有任何 key
 *                          因为左子节点已经没有 key，它无法维持平衡，树必须进行调整
 *               处理步骤：
 *                   父节点 key 下移：这时，父节点的 key [20] 会下移到左子节点，左子节点会成为新根节点，
 *               结构如下
 *                   [25, 30]
 *               现在，树的高度从 2 降低到 1，新的根节点（也是叶子节点）成为 [25, 30]
 *
 *   TODO
 *     max degree = 5,中间叶子节点不富裕时，从富裕的左兄弟借 key
 *                        [25, 50]
 *                       /    |    \
 *          [5, 10, 15, 20] [30, 35, 40] [55, 60, 65]
 *              1.删除 key = 35：
 *                  删除 key 35 后，中间子节点变为 [30, 40]，此时中间子节点有 2 个 key，仍然满足 B+ 树的最小 key 数要求（最少 2 个 key）
 *                        [25, 50]
 *                       /    |    \
 *          [5, 10, 15, 20] [30, 40] [55, 60, 65]
 *              2.删除 key = 30：
 *                  删除 key 30 后，中间子节点只剩下 [40]，不再满足平衡要求（至少需要 2 个 key）。
 *                  需要从左兄弟借 key，左兄弟有足够的 key，可以借出一个 key。
 *                        [25, 50]
 *                       /    |    \
 *          [5, 10, 15, 20] [40] [55, 60, 65]
 *              从左兄弟借 key 的过程
 *                  左兄弟富裕：左兄弟 [5, 10, 15, 20] 有 4 个 key，可以借出最大的 key 20。
 *                  借用 key：中间子节点从左兄弟借出 20，中间子节点变为 [20, 40]。
 *                        [25, 50]
 *                       /    |    \
 *            [5, 10, 15]  [20,40] [55, 60, 65]
 *                  父节点的 key 更新：
 *                      父节点的 key [25] 用来分隔左右兄弟和中间子节点。由于中间子节点的最小 key 现在变成了 20
 *                        [20, 50]
 *                      /    |    \
 *            [5, 10, 15] [20, 40] [55, 60, 65]
 *      max degree = 5 ，中间叶子节点不富裕时，其中左兄弟不富裕，当前节点从富裕的右兄弟借 key
 *                      [25, 50]
 *                      /   |    \
 *              [5, 10] [30, 35] [55, 60, 65, 70]
 *              1.删除 key = 35：
 *                  删除 key 35 后，中间子节点只剩下 [30]，此时中间子节点已经不富裕（至少需要 2 个 key），所以需要借用 key
 *                  左兄弟 [5, 10] 不富裕，只有 2 个 key，不能借 key
 *                      [25, 50]
 *                      /   |    \
 *               [5, 10]   [30] [55, 60, 65, 70]
 *              从右兄弟借 key 的过程
 *                  右兄弟富裕：右兄弟 [55, 60, 65, 70] 有 4 个 key，富裕，可以借出最小的 key 55。
 *                  借用 key：中间子节点从右兄弟借出 55，中间子节点变为 [30, 55]。
 *                      [25, 50]
 *                      /   |    \
 *               [5, 10] [30,55] [60, 65, 70]
 *                  父节点的 key 更新：
 *                      父节点的 key [50] 用来分隔中间子节点和右兄弟。由于右兄弟的最小 key 现在变成了 60，
 *                      父节点的 key [50] 应更新为右兄弟的新最小 key，即 60
 *  TODO
 *   对于非叶子结点中key的删除
 *     case4：
 *            1.非叶子节点 key 的个数 > ⌈m/2⌉ - 1，则删除操作结束，否则执行 2
 *            2.若兄弟节点有富余，父结点 key 下移，兄弟节点 key 上移，删除结束，否则执行 3
 *            3.兄弟节点没富余，当前结点，兄弟节点，父结点 合并成一个新的结点 (树的高度会降低，因为原有父节点会变成空节点) , 然后 重复 1
 *                        开始  <———————————————————————————————————————————————————————————————————————————————————————————
 *                         |                                                                                               |
 *                   删除该叶子结点中的key                                                                                   |
 *                         |                                                                                               |
 *                         V                                                                                               |
 *        判断: 非叶子节点 key 数量 > m/2 - 1?                                                                               |
 *                         |                                                                                               |
 *      <———————————— 是 —————— 否 ———————————>                                                                            |
 *     |                                          |                                                                        |
 *     |                                 判断是否有左兄弟                                                                    |
 *     |                                          |                                                                        |
 *     |                               <————— 是 —————— 否 ——————>                                                         |
 *     |                               |                          |                                                        |
 *     |               判断：左兄弟节点是否有富余(> ⌈m/2⌉ - 1)?      |  走到这里一定有右兄弟，                                   |
 *     |                               |                          |  因为没有左右兄弟的情况上面分析了                          |
 *     |               <————————— 是 —————— 否 —————————————————> |                                                         |
 *     |               |                                          |                                                        |
 *     |               |                                          |                                                        |
 *     |      向左兄弟节点借一个 key                   判断：右兄弟节点是否有富余(> ⌈m/2⌉ - 1)?                                  |
 *     |               |                                          |                                                        |
 *     |     当前节点的父节点 key 下移          <———————————— 是 —————— 否 ———————————>                                       |
 *     |               |                     |                                      |                                      |
 *     |      左兄弟节点 key 上移      向右兄弟节点借一个 key          当前节点所有key + 兄弟节点所有key(默认先和左兄弟节点)        |
 *     |               |                     |                       + 当前节点的父节点的某些key 合并成一个新的节点             |
 *     |               |                     |                                      |                                      |
 *     |               |             当前节点的父节点 key 下移        删除当前节点的父节点中的 被上一步合并的key                  |
 *     |               |                     |                                      |                                      |
 *     |               |              右兄弟节点 key 上移               判断：当前节点的父节点是根节点?                          |
 *     |               |                     |                                      |                                      |
 *     |               |                     |                   <———————————— 是 —————— 否 ————————————>                   |
 *     |               |                     |                  |                                       |                  |
 *     |               |                     |              树高度降低              递归向上处理父节点(对父节点做重复的操作)     |
 *     |               |                     |                  |                                       |                  |
 *     |               |                     |            子节点提升为根节点                              V                  |
 *     |               |                     |                  |                                        —————————————————>
 *     |               |                     |                  |
 *     —————————————————————————————————> 删除操作结束 <———————————
 *     非叶子节点中key的删除的流程图
 *                       开始  <————————————————————————————————————————————————————————————————————————————————————
 *                        |                                                                                        |
 *                        V                                                                                        |
 *         判断: 非叶子节点 key 数量 > m/2 - 1?                                                                      |
 *                        |                                                                                       |
 *      ———————————— 是 —————— 否 —————————————                                                                    |
 *     |                                      |                                                                    |
 *     |                            判断: 兄弟节点有富余(> ⌈m/2⌉ - 1)?                                                |
 *     |                                      |                                                                    |
 *     |                    ———————————— 是 —————— 否 ————————————                                                 |
 *     |                   |                                      |                                                |
 *     |              父节点 key 下移,                  当前节点 + 兄弟节点 + 父节点                                   |
 *     |                   |                                      |                                                |
 *     |             兄弟节点 key 上移                       合并成一个新的节点                                        |
 *     |                   |                                      |                                                |
 *     |                   |                            判断: 父节点是根节点?                                        |
 *     |                   |                                      |                                                |
 *     |                   |                    ———————————— 是 —————— 否 ————————————                              |
 *     |                   |                   |                                      |                            |
 *     |                   |               树高度降低，                      合并后继续处理父节点,结束                  |
 *     |                   |                   |                                      |                            |
 *     |                   |            子节点提升为根节点               递归向上处理父节点(对父节点做重复的操作)         |
 *     |                   |                   |                                      |                            |
 *     |                   |                   |                       判断: 父节点 key 数量 > m/2 - 1?              |
 *     |                   |                   |                                      |                            |
 *     |                   |                   |                            ————— 是 ————— 否 —————                |
 *     |                   V                   V                           |                       |               |
 *     —————————————>   删除操作结束  <——————————————————————————————————————                 对 父节点 重复流程 ——————|
 *
 * TODO
 *  特殊情况:
 *   根节点的删除规则
 *    情况说明：
 *      根节点的删除是B+树中一个特殊的情况，因为根节点的删除可能会导致树的高度减少。
 *      根节点的处理方式与普通内部节点类似，但当根节点中的元素数不足时，树的层次可能会改变。
 *    删除步骤：
 *      1.删除根节点中的索引值：
 *          1.如果要删除的元素在根节点中，则首先找到替代值（通常是子树中的最大或最小值），并递归删除替代值。
 *      2.检查根节点是否需要合并：
 *          1.如果删除后根节点的元素数不足，且根节点有多个子节点，可以尝试进行借位重分配，或将子节点合并。
 *          2.如果根节点的元素数为0（即删除后根节点没有元素），则将根节点的两个子节点合并，并将合并后的节点作为新的根节点。这会导致树的高度减少。
 *      3.树高度减少：
 *          1.当根节点中的元素数为0时，树的高度会减少，子节点会合并成新的根节点。这种情况会发生在根节点的子节点只有一个或两个时。
 *      递归修复的规则：
 *          根节点的删除不会引发常规的向下递归修复，但如果根节点的删除影响了子节点的平衡性，可能需要递归修复子节点。
 *
 *TODO
 * max degree = 5  依次顺序插入 1~37
 *                                                                    [ 19 ]
 *                                            ↙                                                         ↘
 *                            [ 7 | 13]                                                                       [ 25 | 31 ]
 *                  ↙             ↓                    ↘                                          ↙                ↓                   ↘
 *          [3|5]               [9|11]                    [15|17]                    [21|23]                    [27|29]                    [33|35]
 *     ↙     ↓     ↘        ↙     ↓     ↘           ↙        ↓       ↘         ↙        ↓       ↘         ↙        ↓       ↘          ↙        ↓       ↘
 * [1|2]->[3|4]->[5|6]->[7|8]->[9|10]->[11|12]->[13|14]->[15|16]->[17|18]->[19|20]->[21|22]->[23|24]->[25|26]->[27|28]->[29|30]->[31|32]->[33|34]->[35|36|37]
 *  1.删除叶子结点的key = 27
 *                                                                    [ 19 ]
 *                                            ↙                                                         ↘
 *                            [ 7 | 13]                                                                       [ 25 | 31 ]
 *                  ↙             ↓                    ↘                                          ↙                ↓                   ↘
 *          [3|5]               [9|11]                    [15|17]                    [21|23]                    [27|29]                    [33|35]
 *     ↙     ↓     ↘        ↙     ↓     ↘           ↙        ↓       ↘         ↙        ↓       ↘         ↙        ↓       ↘          ↙        ↓       ↘
 * [1|2]->[3|4]->[5|6]->[7|8]->[9|10]->[11|12]->[13|14]->[15|16]->[17|18]->[19|20]->[21|22]->[23|24]->[25|26]->[  |28]->[29|30]->[31|32]->[33|34]->[35|36|37]
 *                                                                                                               ↑
 *                                                                                                               |
 *  2.此时针对叶节点的删除 ，但是该叶子结点的左右子节点都不富裕
 *      2.1当前叶子节点与左兄弟兄弟节点合并
 *                                                                    [ 19 ]
 *                                            ↙                                                         ↘
 *                            [ 7 | 13]                                                                       [ 25 | 31 ]
 *                  ↙             ↓                    ↘                                          ↙                ↓                   ↘
 *          [3|5]               [9|11]                    [15|17]                    [21|23]                    [27|29]                    [33|35]
 *     ↙     ↓     ↘        ↙     ↓     ↘           ↙        ↓       ↘         ↙        ↓       ↘         ↙            ↘          ↙        ↓       ↘
 * [1|2]->[3|4]->[5|6]->[7|8]->[9|10]->[11|12]->[13|14]->[15|16]->[17|18]->[19|20]->[21|22]->[23|24]-> [25|26|28] ->[29|30] -> [31|32]->[33|34]->[35|36|37]
 *                                                                                                          ↑
 *                                                                                                          |
 *      2.2删除父节点的key 因为子节点数量变少了
 *                                                                    [ 19 ]
 *                                            ↙                                                         ↘
 *                            [ 7 | 13]                                                                       [ 25 | 31 ]
 *                  ↙             ↓                    ↘                                          ↙                ↓                   ↘
 *          [3|5]               [9|11]                    [15|17]                    [21|23]                    [29] ☆☆☆☆☆             [33|35]
 *     ↙     ↓     ↘        ↙     ↓     ↘           ↙        ↓       ↘         ↙        ↓       ↘         ↙              ↘          ↙        ↓       ↘
 * [1|2]->[3|4]->[5|6]->[7|8]->[9|10]->[11|12]->[13|14]->[15|16]->[17|18]->[19|20]->[21|22]->[23|24]-> [25|26|28] ->[29|30] -> [31|32]->[33|34]->[35|36|37]
 *  3.此时父节点[29] 不满足要求
 *      但是该结点的左右子节点都不富裕
 *      3.1 当前节点 + 兄弟节点 + 父节点 合并成一个新的节点
 *         3.1.1 当前节点 + 左兄弟节点
 *                                                                    [ 19 ]
 *                                            ↙                                                         ↘
 *                            [ 7 | 13]                                                                       [ 25 | 31 ]
 *                  ↙             ↓                    ↘                                          ↙                                   ↘
 *          [3|5]               [9|11]                    [15|17]                        [21|23|29]                                  [33|35]
 *        ↙  ↓  ↘             ↙   ↓  ↘                ↙     ↓    ↘               ↙         ↙            ↘         ↘                 ↙     ↓    ↘
 *     ↙     ↓     ↘       ↙     ↓     ↘           ↙        ↓       ↘         ↙         ↙                  ↘         ↘            ↙       ↓       ↘
 * [1|2]->[3|4]->[5|6]->[7|8]->[9|10]->[11|12]->[13|14]->[15|16]->[17|18]->[19|20]->[21|22]->[23|24]-> [25|26|28] ->[29|30] -> [31|32]->[33|34]->[35|36|37]
 *         3.1.2 再和父节点合并
 *                                                                    [ 19 ]
 *                                            ↙                                                         ↘
 *                            [ 7 | 13]                                                                       [    | 31 ]
 *                  ↙             ↓                    ↘                                          ↙                                   ↘
 *          [3|5]               [9|11]                    [15|17]                       [21|23|25|29]                                 [33|35]
 *        ↙  ↓  ↘             ↙   ↓  ↘                ↙     ↓    ↘               ↙         ↙            ↘         ↘                 ↙     ↓    ↘
 *     ↙     ↓     ↘       ↙     ↓     ↘           ↙        ↓       ↘         ↙         ↙                  ↘         ↘            ↙       ↓       ↘
 * [1|2]->[3|4]->[5|6]->[7|8]->[9|10]->[11|12]->[13|14]->[15|16]->[17|18]->[19|20]->[21|22]->[23|24]-> [25|26|28] ->[29|30] -> [31|32]->[33|34]->[35|36|37]
 *  3.此时父节点[  |31] 不满足要求
 *      但是该结点的左子节点不富裕(没有右子节点)
 *      3.1 当前节点 + 兄弟节点 + 父节点 合并成一个新的节点
 *         3.1.1 当前节点 + 左兄弟节点
 *                                                                    [ 19 ]
 *                                            ↙
 *                            [ 7 | 13 | 31]                                                                       [    ]
 *                  ↙             ↓                    ↘                                          ↙                                   ↘
 *          [3|5]               [9|11]                    [15|17]                       [21|23|25|29]                                 [33|35]
 *        ↙  ↓  ↘             ↙   ↓  ↘                ↙     ↓    ↘               ↙         ↙            ↘         ↘                 ↙     ↓    ↘
 *     ↙     ↓     ↘       ↙     ↓     ↘           ↙        ↓       ↘         ↙         ↙                  ↘         ↘            ↙       ↓       ↘
 * [1|2]->[3|4]->[5|6]->[7|8]->[9|10]->[11|12]->[13|14]->[15|16]->[17|18]->[19|20]->[21|22]->[23|24]-> [25|26|28] ->[29|30] -> [31|32]->[33|34]->[35|36|37]
 *         3.1.2 再和父节点合并
 *                                                                  [ ]
 *                                                                   ↓
 *                                                          [ 7 | 13 | 31 | 19]
 *                        ↙            ↙                     ↓                          ↘                                   ↘
 *                    ↙             ↙                        ↓                             ↘                                   ↘
 *          [3|5]               [9|11]                    [15|17]                           [21|23|25|29]                             [33|35]
 *        ↙  ↓  ↘             ↙   ↓  ↘                ↙     ↓    ↘               ↙         ↙            ↘         ↘                 ↙     ↓    ↘
 *     ↙     ↓     ↘       ↙     ↓     ↘           ↙        ↓       ↘         ↙         ↙                  ↘         ↘            ↙       ↓       ↘
 * [1|2]->[3|4]->[5|6]->[7|8]->[9|10]->[11|12]->[13|14]->[15|16]->[17|18]->[19|20]->[21|22]->[23|24]-> [25|26|28] ->[29|30] -> [31|32]->[33|34]->[35|36|37]
 *  TODO
 *   eg:
 *    max degree = 5
 *    5阶B数的结点最少⌈5/2⌉ - 1 = 2 个key，最多4个key
 *    初始:
 *                              [ 16 |   ]
 *                          ↙                ↘
 *              [ 7 | 10]                    [ 18 | 20 ]
 *           ↙      ↓       ↘            ↙         ↓         ↘
 *     [5|6] -> [7|8|9] -> [10|15] -> [16|17] -> [18|19] -> [20|21|22]
 *    删除22，这里是case1
 *                              [ 16 |   ]
 *                          ↙                ↘
 *              [ 7 | 10]                     [ 18 | 20 ]
 *           ↙      ↓       ↘            ↙         ↓         ↘
 *     [5|6] -> [7|8|9] -> [10|15] -> [16|17] -> [18|19] -> [20|21| ]
 *     删除15，这里是case2
 *                              [ 16 |   ]
 *                          ↙                ↘
 *              [ 7 | 10]                     [ 18 | 20 ]
 *           ↙      ↓       ↘            ↙         ↓         ↘
 *     [5|6] -> [7|8|9] -> [10|  ] -> [16|17] -> [18|19] -> [20|21| ]
 *     向兄弟 借 9
 *                              [ 16 |   ]
 *                          ↙                ↘
 *              [ 7 | 10]                     [ 18 | 20 ]
 *           ↙      ↓       ↘            ↙         ↓         ↘
 *     [5|6] -> [7|8| ] -> [9 |10] -> [16|17] -> [18|19] -> [20|21| ]
 *     修改父节点 因为原始 父节点  [ 7 | 10] 表示 [6，7) ∪ [7，10) ∪ [10，16)
 *     现在节点[7 | 10]的10这个key的右侧孩子 是 [9 |10] 不满足 [10，16) ，需要修改
 *     最终
 *                              [ 16 |   ]
 *                          ↙                ↘
 *              [ 7 | 9 ]                     [ 18 | 20 ]
 *           ↙      ↓       ↘            ↙         ↓         ↘
 *     [5|6] -> [7|8| ] -> [9 |10] -> [16|17] -> [18|19] -> [20|21| ]
 *     删除7，这里是case3
 *                              [ 16 |   ]
 *                          ↙                ↘
 *              [ 7 | 9 ]                     [ 18 | 20 ]
 *           ↙      ↓       ↘            ↙         ↓         ↘
 *     [5|6] -> [ |8| ] -> [9 |10] -> [16|17] -> [18|19] -> [20|21| ]
 *     删除叶子结点的7之后，其父节点中的7也要被删除，
 *                              [ 16 |   ]
 *                          ↙                ↘
 *              [   | 9 ]                     [ 18 | 20 ]
 *           ↙      ↓       ↘            ↙         ↓         ↘
 *     [5|6] -> [ |8| ] -> [9 |10] -> [16|17] -> [18|19] -> [20|21| ]
 *     调整父节点的区间，保证父节点的区间任然有效，因为下面有3个节点 相当于三个区间，那么父节点需要2个值
 *     所以 将 key = 8 上升
 *                              [ 16 |   ]
 *                          ↙                ↘
 *              [ 8 | 9 ]                     [ 18 | 20 ]
 *           ↙      ↓       ↘            ↙         ↓         ↘
 *     [5|6] -> [ |8| ] -> [9 |10] -> [16|17] -> [18|19] -> [20|21| ]
 *     此时 再考虑 兄弟节点的key不够借 需要合并
 *     对于[ |8| ] 左侧兄弟[5|6]和右侧兄弟[9 |10] 都不够借，因为借完之后左右侧兄弟都不富裕了
 *     可以和左侧合并，也可以和右侧合并，这里选择 优先和左侧合并 ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
 *     这里的非叶子结点[ 8 | 9 ] 中的8也要删除
 *          因为 子节点个数 由 3个 变成 2个
 *          左侧子节点 [5|6|8] 都 < 9
 *          左侧子节点 [9|10] 都 > 9
 *                          [ 16 |   ]
 *                      ↙                ↘
 *              [9]                          [ 18 | 20 ]
 *           ↙       ↘                  ↙         ↓         ↘
 *         [5|6|8] -> [9|10] -> [16|17] -> [18|19] -> [20|21| ]
 *     因为删除了 非叶子结点 [ 8 | 9 ] 中的8 ，这里执行case4
 *     因为[9]也不富余 这里执行case4的条件3
 *     那么
 *                             [ ]
 *                              ↓
 *                    [  9 | 16 | 18 | 20 ]
 *           ↙            ↙     ↓     ↘      ↘
 *      [5|6|8] -> [9|10] -> [16|17] -> [18|19] -> [20|21| ]
 *      最终
 *                    [  9 | 16 | 18 | 20 ]
 *           ↙            ↙     ↓     ↘      ↘
 *      [5|6|8] -> [9|10] -> [16|17] -> [18|19] -> [20|21| ]
 *
 *  TODO
 *      针对非叶子结点的删除的情况2
 *      max degree = 3  ⌈m/2⌉ - 1 = 2
 *            [4  | 10]
 *          /     |     \
 *       [2]   [6 | 8]   [12| 14]
 *      删除 6
 *            [4  | 10]
 *          /     |     \
 *       [2]     [8]   [12| 14]
 *       删除 6 后，第二个子节点 [6, 8] 变成了 [8]，此时关键字数量不足（小于 ⌈m/2⌉ - 1）。
 *       检查左兄弟节点 [2]，没有多余关键字；接着检查右兄弟节点 [12, 14]，右兄弟有多余关键字。
 *       借用操作发生，父节点的 10 下移到当前节点 [8]，右兄弟的 12 上移到父节点。结果是
 *            [4  | 12]
 *          /     |     \
 *       [2]     [8]   [14]
 *            [4  | 12]
 *          /     |     \
 *       [2]   [ 8 |10]   [14]
 * </pre>
 *
 * @Description
 * @Author veritas
 * @Data 2024/9/14 15:31
 */
public class BPlusTree2 {
    private int m; // B+树的阶数（每个节点的最大子节点数）
    private BPlusTreeNode root; // 根节点

    // B+树的节点类
    class BPlusTreeNode {
        boolean isLeaf;               // 是否为叶子节点
        List<Integer> keys;           // 关键字列表
        List<String> values;          // 值列表，仅叶子节点使用
        List<BPlusTreeNode> children; // 子节点列表（仅内部节点使用）
        BPlusTreeNode next;           // 叶子节点的指针，用于链接叶子节点

        // 构造函数
        public BPlusTreeNode(boolean isLeaf) {
            this.isLeaf = isLeaf;            // 设置节点类型
            this.keys = new ArrayList<>();   // 初始化关键字列表
            if (isLeaf) {
                this.values = new ArrayList<>(); // 初始化值列表
            } else {
                this.children = new ArrayList<>(); // 初始化子节点列表
            }
        }
    }

    // 构造函数
    public BPlusTree2(int m) {
        if (m < 3) {
            throw new IllegalArgumentException("B+树的阶数必须大于等于3"); // 阶数必须至少为3
        }
        this.m = m;                       // 设置阶数
        this.root = new BPlusTreeNode(true); // 初始化根节点为叶子节点
    }

    // 搜索操作
    public String search(int key) {
        BPlusTreeNode node = root;       // 从根节点开始
        while (!node.isLeaf) {           // 如果不是叶子节点
            int i = 0;
            while (i < node.keys.size() && key >= node.keys.get(i)) {
                i++;                     // 找到子节点索引
            }
            node = node.children.get(i); // 进入子节点
        }
        int i = 0;
        while (i < node.keys.size()) {
            if (key == node.keys.get(i)) {
                return node.values.get(i); // 找到关键字，返回对应的值
            }
            i++;
        }
        return null; // 未找到关键字
    }

    // 插入操作
    public void insert(int key, String value) {
        BPlusTreeNode node = root;       // 从根节点开始
        if (node.keys.size() == m - 1) {
            // 根节点已满，需要分裂
            BPlusTreeNode newRoot = new BPlusTreeNode(false); // 创建新根节点
            newRoot.children.add(root);  // 新根节点的第一个子节点为旧根节点
            splitChild(newRoot, 0, root); // 分裂旧根节点
            root = newRoot;              // 更新根节点
        }
        insertNonFull(root, key, value); // 在非满节点中插入
    }

    // 在非满节点中插入关键字
    private void insertNonFull(BPlusTreeNode node, int key, String value) {
        if (node.isLeaf) {
            // 如果是叶子节点，插入或更新值
            int i = 0;
            while (i < node.keys.size() && key > node.keys.get(i)) {
                i++; // 找到插入位置
            }
            if (i < node.keys.size() && key == node.keys.get(i)) {
                // 关键字已存在，更新值
                node.values.set(i, value);
            } else {
                // 插入新的关键字和值
                node.keys.add(i, key);
                node.values.add(i, value);
            }
        } else {
            // 如果是内部节点
            int i = 0;
            while (i < node.keys.size() && key >= node.keys.get(i)) {
                i++; // 找到子节点索引
            }
            BPlusTreeNode child = node.children.get(i); // 获取子节点
            if (child.keys.size() == m - 1) {
                // 子节点已满，需要分裂
                splitChild(node, i, child);
                if (key >= node.keys.get(i)) {
                    i++; // 确定正确的子节点
                }
            }
            insertNonFull(node.children.get(i), key, value); // 递归插入
        }
    }

    // 分裂子节点
    private void splitChild(BPlusTreeNode parent, int index, BPlusTreeNode node) {
        int mid = m / 2;                 // 中间索引
        BPlusTreeNode newNode = new BPlusTreeNode(node.isLeaf); // 创建新节点
        // 将关键字和子节点分裂到新节点
        newNode.keys.addAll(node.keys.subList(mid, node.keys.size())); // 复制右半部分关键字
        node.keys.subList(mid, node.keys.size()).clear();              // 移除原节点的右半部分关键字

        if (node.isLeaf) {
            // 如果是叶子节点
            newNode.values = new ArrayList<>(node.values.subList(mid, node.values.size())); // 复制右半部分值
            node.values.subList(mid, node.values.size()).clear();                           // 移除原节点的右半部分值

            // 更新叶子节点的链接
            newNode.next = node.next; // 新节点的下一个节点为原节点的下一个节点
            node.next = newNode;      // 原节点的下一个节点为新节点

            // 将新节点的第一个关键字插入父节点
            parent.keys.add(index, newNode.keys.get(0));
            parent.children.add(index + 1, newNode);
        } else {
            // 如果是内部节点
            newNode.children = new ArrayList<>(node.children.subList(mid, node.children.size())); // 复制右半部分子节点
            node.children.subList(mid, node.children.size()).clear();                             // 移除原节点的右半部分子节点

            int upKey = node.keys.remove(mid - 1); // 提升的关键字

            // 将提升的关键字插入父节点
            parent.keys.add(index, upKey);
            parent.children.add(index + 1, newNode);
        }
    }

    // 删除操作
    public void delete(int key) {
        delete(root, key); // 从根节点开始删除
        // 如果根节点为空且不是叶子节点，降低树的高度
        if (!root.isLeaf && root.keys.size() == 0) {
            root = root.children.get(0); // 更新根节点
        }
    }

    private boolean delete(BPlusTreeNode node, int key) {
        int idx = 0;
        while (idx < node.keys.size() && key > node.keys.get(idx)) {
            idx++; // 找到关键字的位置
        }
        if (node.isLeaf) {
            // 在叶子节点中删除
            if (idx < node.keys.size() && key == node.keys.get(idx)) {
                node.keys.remove(idx);   // 移除关键字
                node.values.remove(idx); // 移除对应的值
                return true;             // 删除成功
            }
            return false; // 未找到关键字
        } else {
            // 在内部节点中删除
            BPlusTreeNode child = node.children.get(idx); // 获取子节点
            boolean deleted = delete(child, key);         // 递归删除
            if (child.keys.size() < (m - 1) / 2) {
                // 子节点关键字数不足，需要调整
                rebalance(node, idx);
            }
            return deleted;
        }
    }

    // 重新平衡节点
    private void rebalance(BPlusTreeNode parent, int idx) {
        BPlusTreeNode node = parent.children.get(idx);                          // 当前节点
        BPlusTreeNode leftSibling = idx > 0 ? parent.children.get(idx - 1) : null; // 左兄弟节点
        BPlusTreeNode rightSibling = idx < parent.children.size() - 1 ? parent.children.get(idx + 1) : null; // 右兄弟节点

        if (leftSibling != null && leftSibling.keys.size() > (m - 1) / 2) {
            // 从左兄弟借一个关键字
            if (node.isLeaf) {
                node.keys.add(0, leftSibling.keys.remove(leftSibling.keys.size() - 1)); // 移动关键字
                node.values.add(0, leftSibling.values.remove(leftSibling.values.size() - 1)); // 移动值
                parent.keys.set(idx - 1, node.keys.get(0)); // 更新父节点的关键字
            } else {
                node.keys.add(0, parent.keys.get(idx - 1)); // 将父节点的关键字下移
                parent.keys.set(idx - 1, leftSibling.keys.remove(leftSibling.keys.size() - 1)); // 左兄弟的最大关键字上移
                node.children.add(0, leftSibling.children.remove(leftSibling.children.size() - 1)); // 移动子节点
            }
        } else if (rightSibling != null && rightSibling.keys.size() > (m - 1) / 2) {
            // 从右兄弟借一个关键字
            if (node.isLeaf) {
                node.keys.add(rightSibling.keys.remove(0)); // 移动关键字
                node.values.add(rightSibling.values.remove(0)); // 移动值
                parent.keys.set(idx, rightSibling.keys.get(0)); // 更新父节点的关键字
            } else {
                node.keys.add(parent.keys.get(idx)); // 将父节点的关键字下移
                parent.keys.set(idx, rightSibling.keys.remove(0)); // 右兄弟的最小关键字上移
                node.children.add(rightSibling.children.remove(0)); // 移动子节点
            }
        } else {
            // 需要合并节点
            if (leftSibling != null) {
                if (node.isLeaf) {
                    leftSibling.keys.addAll(node.keys);   // 合并关键字
                    leftSibling.values.addAll(node.values); // 合并值
                    leftSibling.next = node.next;         // 更新链表指针
                } else {
                    leftSibling.keys.add(parent.keys.remove(idx - 1)); // 父节点的关键字下移
                    leftSibling.keys.addAll(node.keys);                // 合并关键字
                    leftSibling.children.addAll(node.children);        // 合并子节点
                }
                parent.children.remove(idx); // 移除被合并的节点
            } else if (rightSibling != null) {
                if (node.isLeaf) {
                    node.keys.addAll(rightSibling.keys);   // 合并关键字
                    node.values.addAll(rightSibling.values); // 合并值
                    node.next = rightSibling.next;         // 更新链表指针
                } else {
                    node.keys.add(parent.keys.remove(idx)); // 父节点的关键字下移
                    node.keys.addAll(rightSibling.keys);    // 合并关键字
                    node.children.addAll(rightSibling.children); // 合并子节点
                }
                parent.children.remove(idx + 1); // 移除被合并的节点
            }
        }
    }

    // 中序遍历打印树（用于调试）
    public void printTree() {
        printTree(root, 0); // 从根节点开始打印，层级为0
    }

    private void printTree(BPlusTreeNode node, int level) {
        if (node != null) {
            if (node.isLeaf) {
                // 打印叶子节点
                System.out.print("Level " + level + " [叶节点]: ");
                for (int key : node.keys) {
                    System.out.print(key + " ");
                }
                System.out.println();
            } else {
                // 打印内部节点
                System.out.print("Level " + level + " [内部节点]: ");
                for (int key : node.keys) {
                    System.out.print(key + " ");
                }
                System.out.println();
                for (BPlusTreeNode child : node.children) {
                    printTree(child, level + 1); // 递归打印子节点，层级加1
                }
            }
        }
    }
}
