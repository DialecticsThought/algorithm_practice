package heima_data_structure.java.src.main.java.com.itheima.algorithm.dynamicprogramming;

import java.util.Arrays;
import java.util.stream.Collectors;

/**
 * <h3>旅行商问题</h3>
 */
public class TravellingSalesmanProblem {

    /**
     * 这个问题不是最短路径问题
     * <pre>
     *              北京(0)
     *             /  |  \
     *            /   |   \
     *           /    |    \
     *          /   3 |     \
     *       1 /    武汉(3)  \ 2
     *        /   ／      ＼  \
     *       /  ／ 4     5  ＼ \
     *      / ／              ＼\
     * 上海(1)---------6---------西安(2)
     *
     * 北京->
     * 上海->
     * 武汉->
     * 西安->
     * 表示分别从这个城市作为出发点，把其他3个城市都逛完所需要的成本
     * 无->|
     *    |--北京->|
     *    |       |--上海->|
     *    |       |       |--武汉->|
     *    |       |       |       |--西安->|
     *    |       |       |               |--北京
     *    |       |       |
     *    |       |       |--西安->|
     *    |       |               |--武汉->|
     *    |       |                       |--北京
     *    |       |--武汉->|
     *    |       |       |--上海->|
     *    |       |       |       |--西安->|
     *    |       |       |               |--北京
     *    |       |       |
     *    |       |       |--西安->|
     *    |       |               |--上海->|
     *    |       |                       |--北京
     *    |       |--西安->|
     *    |               |--上海->|
     *    |               |       |--武汉->|
     *    |               |               |--北京
     *    |               |
     *    |               |--武汉->|
     *    |                       |--上海->|
     *    |                               |--北京
     *    |--上海->
     *          ..........
     *    |--武汉->
     *          ..........
     *    |--西安->
     *          ..........
     * 上面的流程得到
     * 5个城市: 4 * 3 * 2 * 1 = 24 => 4!
     * 可以推广成:n个城市: (n-1)!
     * 无向拓扑图graph:
     * 北京:0 , 上海:1 , 西安:2 , 武汉:3
     *     0  1  2  3
     * 0  {0, 1, 2, 3}
     * 1  {1, 0, 6, 4}
     * 2  {2, 6, 0, 5}
     * 3  {3, 4, 5, 0}
     * graph[i][j] 表示: 城市i -> 城市j 的距离
     * 用动态规划求解:
     *  有一个方法d(出发城市, 剩余城市集合)
     *          ==> 从出发城市开始，走完剩余城市，花费的最少代价
     *  原始问题:
     *  d(0,[1|2|3])
     *      => g[0][1] + d(1,[2|3])
     *                      => g[1][2] + d(2,[3])
     *                                      => g[2][3] + d(3,[])
     *                      => g[1][3] + d(3,[2])
     *                                      => g[3][2] + d(2,[])
     *      => g[0][2] + d(2,[1|3])
     *                      => g[2][1] + d(1,[3])
     *                                      => g[1][3] + d(3,[])
     *                      => g[2][3] + d(3,[1])
     *                                      => g[3][1] + d(1,[])
     *      => g[0][3] + d(3,[1|2])
     *                      => g[3][1] + d(1,[2])
     *                                      => g[1][2] + d(2,[])
     *                      => g[3][2] + d(2,[1])
     *                                      => g[2][1] + d(1,[])
     * ==> 问题 被拆分成 距离 + 子问题
     * 设 出发城市 = i , 剩余城市集合 = j , 遍历 j 时的变量 k （剩余的某一个城市)
     * 问题 就是 d(出发城市, 剩余城市集合)
     * 那么 d(i, j) => min(
     *                  遍历 j 时的变量 k
     *                  g[i][k] + d(k, j去掉k)
     *                  g[i][k] + d(k, j去掉k)
     *                  g[i][k] + d(k, j去掉k)
     *                  )
     * 子问题的特殊情况(base case) d(k,空) => 从k回到起点 => g[k][i]
     *
     * 现在用 位来表示 城市，对于城市i,那么用第i位 = 1 表示
     * eg:
     * 二进制      十进制
     * 000 没城市    0
     * 001 1号      1
     * 010 2号      2
     * 100 3号      4
     * 011 1和2     3
     * 101 1和3     5
     * 110 2和3     6
     * 111 1和2和3  7
     * dp表 列是j,行是1 但是特殊的是列是一个集合☆☆☆☆☆
     *     0   1   2   3    4   5    6    7     j 剩余城市集合
     * 0   1   2   1|2  3   1|3  2|3  1|2|3
     * 0
     * 1
     * 2
     * 3
     * i 出发城市
     * 上面的 dp[0][7] 表示 出发城市是 0, 要去往城市1和2和3的最小距离，因为(7)10 = (111)2
     * 其实 这也说明了 3个城市 有 8种组合(2^3) 分别用十进制的0 ~ 7 表示
     * 0 这个情况，表示什么城市都不去,没有目的地，原地不动 <===>表示集合是空集
     * 那么 上面的
     *  d(0,[1|2|3])
     *      => g[0][1] + d(1,[2|3])
     *                      => g[1][2] + d(2,[3])
     *                                      => g[2][3] + d(3,[])
     *                      => g[1][3] + d(3,[2])
     *                                      => g[3][2] + d(2,[])
     *      => g[0][2] + d(2,[1|3])
     *                      => g[2][1] + d(1,[3])
     *                                      => g[1][3] + d(3,[])
     *                      => g[2][3] + d(3,[1])
     *                                      => g[3][1] + d(1,[])
     *      => g[0][3] + d(3,[1|2])
     *                      => g[3][1] + d(1,[2])
     *                                      => g[1][2] + d(2,[])
     *                      => g[3][2] + d(2,[1])
     *                                      => g[2][1] + d(1,[])
     * 变成了
     *  dp[0,7]
     *      => g[0][1] + dp[1,6]
     *                      => g[1][2] + dp[2,4]
     *                                      => g[2][3] + dp[3,0]
     *                      => g[1][3] + dp[3,2]
     *                                      => g[3][2] + dp[2,0]
     *      => g[0][2] + dp[2,5]
     *                      => g[2][1] + dp[1,4]
     *                                      => g[1][3] + dp[3,0]
     *                      => g[2][3] + dp[3,1]
     *                                      => g[3][1] + dp[1,0]
     *      => g[0][3] + dp[3,3]
     *                      => g[3][1] + dp[1,2]
     *                                      => g[1][2] + dp[2,0]
     *                      => g[3][2] + dp[2,1]
     *                                      => g[2][1] + dp[1,0]
     * 推导是从右向左，填dp表示从左向右
     * </pre>
     * g[2][0]
     * <p>
     * g[3][0]
     * <p>
     * g[3][0]
     * <p>
     * g[1][0]
     * <p>
     * g[2][0]
     * <p>
     * g[1][0]
     * <p>
     * d(0,1|2) => g[0][1] + d(1,2)
     * => g[0][2] + d(2,1)
     * d(1,1|2)
     * d(2,1|2)
     * d(3,1|2) => g[3][1] + d(1,2)
     * => g[3][2] + d(2,1)
     */
    public static void main(String[] args) {
        int[][] graph = {
                {0, 1, 2, 3},
                {1, 0, 6, 4},
                {2, 6, 0, 5},
                {3, 4, 5, 0},
        };
        System.out.println(tsp(graph));
    }

    static int tsp(int[][] g) {
        int m = g.length; // 城市数目
        // 这也说明了 3个城市, 城市1 <=> 001 城市2 <=> 010 城市3 <=> 100 与运算在一起 = (111)2 = (7)10
        // 再加上 0 这个情况，也就是什么城市都不去,原地不动
        // 有 8种组合(2^3) 分别用十进制的0 ~ 7 表示
        int n = 1 << (m - 1); // 剩余城市的组合数  2^(m-1)
        int[][] dp = new int[m][n];

        // 填充第0列
        for (int k = 0; k < m; k++) {
            dp[k][0] = g[k][0];
        }
        print(dp);

        // 填充后续列
        for (int j = 1; j < n; j++) {
            for (int i = 0; i < m; i++) {
                dp[i][j] = Integer.MAX_VALUE / 2;
                if (contains(j, i)) continue; // 剩余城市集合已包含出发城市，不合理
                // 填充单元格
                for (int k = 0; k < m; k++) {
                    if (contains(j, k)) { // 只对剩余城市集合中的城市进行处理
                        dp[i][j] = Integer.min(dp[i][j], g[i][k] + dp[k][exclude(j, k)]);
                    }
                }
            }
        }
        print(dp);
        return dp[0][n - 1];
    }

    /*
        2|3
        110  城市1是否存在    110
                           001 &
                           ----
                           000
                           false
        110  城市2是否存在    011
                           001 &
                           ----
                           001
                           true
        110  城市3是否存在    001
                           001 &
                           ----
                           001
                           true
        110  城市4是否存在    000
                           001 &
                           ----
                           000
                           false

     */
    static boolean contains(int set, int city) {
        return (set >> (city - 1) & 1) == 1;
    }

    /*
        1|2|3  1 => 2|3

        111
        001 ^
        ----
        110     2|3

        1|2|3  2 => 1|3
        111
        010 ^
        ----
        101   1|3
     */
    static int exclude(int set, int city) {
        return set ^ (1 << (city - 1));
    }

    static void print(int[][] dist) {
        System.out.println("-------------------------");
        for (int[] row : dist) {
            System.out.println(Arrays.stream(row).boxed()
                    .map(x -> x >= Integer.MAX_VALUE / 2 ? "∞" : String.valueOf(x))
                    .map(s -> String.format("%2s", s))
                    .collect(Collectors.joining(",", "[", "]")));
        }
    }
}
