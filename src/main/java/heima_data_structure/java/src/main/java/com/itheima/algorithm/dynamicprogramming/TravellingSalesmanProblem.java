package heima_data_structure.java.src.main.java.com.itheima.algorithm.dynamicprogramming;

import java.util.Arrays;
import java.util.stream.Collectors;

/**
 * <h3>旅行商问题</h3>
 */
public class TravellingSalesmanProblem {

    /**
     * 这个问题不是最短路径问题
     * <pre>
     *              北京(0)
     *             /  |  \
     *            /   |   \
     *           /    |    \
     *          /   3 |     \
     *       1 /    武汉(3)  \ 2
     *        /   ／      ＼  \
     *       /  ／ 4     5  ＼ \
     *      / ／              ＼\
     * 上海(1)---------6---------西安(2)
     *
     * 北京->
     * 上海->
     * 武汉->
     * 西安->
     * 表示分别从这个城市作为出发点，把其他3个城市都逛完所需要的成本
     * 无->|
     *    |--北京->|
     *    |       |--上海->|
     *    |       |       |--武汉->|
     *    |       |       |       |--西安->|
     *    |       |       |               |--北京
     *    |       |       |
     *    |       |       |--西安->|
     *    |       |               |--武汉->|
     *    |       |                       |--北京
     *    |       |--武汉->|
     *    |       |       |--上海->|
     *    |       |       |       |--西安->|
     *    |       |       |               |--北京
     *    |       |       |
     *    |       |       |--西安->|
     *    |       |               |--上海->|
     *    |       |                       |--北京
     *    |       |--西安->|
     *    |               |--上海->|
     *    |               |       |--武汉->|
     *    |               |               |--北京
     *    |               |
     *    |               |--武汉->|
     *    |                       |--上海->|
     *    |                               |--北京
     *    |--上海->
     *          ..........
     *    |--武汉->
     *          ..........
     *    |--西安->
     *          ..........
     * 上面的流程得到
     * 5个城市: 4 * 3 * 2 * 1 = 24 => 4!
     * 可以推广成:n个城市: (n-1)!
     * 无向拓扑图graph:
     * 北京:0 , 上海:1 , 西安:2 , 武汉:3
     *     0  1  2  3
     * 0  {0, 1, 2, 3}
     * 1  {1, 0, 6, 4}
     * 2  {2, 6, 0, 5}
     * 3  {3, 4, 5, 0}
     * graph[i][j] 表示: 城市i -> 城市j 的距离
     * 用动态规划求解:
     *  有一个方法d(出发城市, 剩余城市集合)
     *          ==> 从出发城市开始，走完剩余城市，花费的最少代价
     *  原始问题:
     *  d(0,[1|2|3])
     *      => g[0][1] + d(1,[2|3])
     *                      => g[1][2] + d(2,[3])
     *                                      => g[2][3] + d(3,[])
     *                      => g[1][3] + d(3,[2])
     *                                      => g[3][2] + d(2,[])
     *      => g[0][2] + d(2,[1|3])
     *                      => g[2][1] + d(1,[3])
     *                                      => g[1][3] + d(3,[])
     *                      => g[2][3] + d(3,[1])
     *                                      => g[3][1] + d(1,[])
     *      => g[0][3] + d(3,[1|2])
     *                      => g[3][1] + d(1,[2])
     *                                      => g[1][2] + d(2,[])
     *                      => g[3][2] + d(2,[1])
     *                                      => g[2][1] + d(1,[])
     * ==> 问题 被拆分成 距离 + 子问题
     * 设 出发城市 = i , 剩余城市集合 = j , 遍历 j 时的变量 k （剩余的某一个城市)
     * 问题 就是 d(出发城市, 剩余城市集合)
     * 那么 d(i, j) => min(
     *                  遍历 j 时的变量 k
     *                  g[i][k] + d(k, j去掉k)
     *                  g[i][k] + d(k, j去掉k)
     *                  g[i][k] + d(k, j去掉k)
     *                  )
     * 子问题的特殊情况(base case) d(k,空) => 从k回到起点 => g[k][i]
     *
     * 现在用 位来表示 城市，对于城市i,那么用第i位 = 1 表示
     * eg:
     * 二进制      十进制
     * 000 没城市    0
     * 001 1号      1
     * 010 2号      2
     * 100 3号      4
     * 011 1和2     3
     * 101 1和3     5
     * 110 2和3     6
     * 111 1和2和3  7
     * dp表 列是j,行是1 但是特殊的是列是一个集合☆☆☆☆☆
     *     0   1   2   3    4   5    6    7     j 剩余城市集合
     * 0   1   2   1|2  3   1|3  2|3  1|2|3
     * 0
     * 1
     * 2
     * 3
     * i 出发城市
     * 上面的 dp[0][7] 表示 出发城市是 0, 要去往城市集合[1,2,3]的最小距离，
     * [1,2,3] <=> [001,010,100] => 加起来得到 (111)2 = (7)10
     * 其实 这也说明了 3个城市 有 8种组合(2^3) 分别用十进制的0 ~ 7 表示
     * 0 这个情况，表示什么城市都不去,没有目的地，原地不动 <===>表示集合是空集
     * 那么 上面的
     *  d(0,[1|2|3])
     *      => g[0][1] + d(1,[2|3])
     *                      => g[1][2] + d(2,[3])
     *                                      => g[2][3] + d(3,[])
     *                      => g[1][3] + d(3,[2])
     *                                      => g[3][2] + d(2,[])
     *      => g[0][2] + d(2,[1|3])
     *                      => g[2][1] + d(1,[3])
     *                                      => g[1][3] + d(3,[])
     *                      => g[2][3] + d(3,[1])
     *                                      => g[3][1] + d(1,[])
     *      => g[0][3] + d(3,[1|2])
     *                      => g[3][1] + d(1,[2])
     *                                      => g[1][2] + d(2,[])
     *                      => g[3][2] + d(2,[1])
     *                                      => g[2][1] + d(1,[])
     * 变成了
     *  dp[0,7]
     *      => g[0][1] + dp[1,6]
     *                      => g[1][2] + dp[2,4]
     *                                      => g[2][3] + dp[3,0]
     *                      => g[1][3] + dp[3,2]
     *                                      => g[3][2] + dp[2,0]
     *      => g[0][2] + dp[2,5]
     *                      => g[2][1] + dp[1,4]
     *                                      => g[1][3] + dp[3,0]
     *                      => g[2][3] + dp[3,1]
     *                                      => g[3][1] + dp[1,0]
     *      => g[0][3] + dp[3,3]
     *                      => g[3][1] + dp[1,2]
     *                                      => g[1][2] + dp[2,0]
     *                      => g[3][2] + dp[2,1]
     *                                      => g[2][1] + dp[1,0]
     * 推导是从右向左，填dp表示从左向右 ☆☆☆☆☆☆☆☆☆☆☆☆
     * </pre>
     */
    public static void main(String[] args) {
        int[][] graph = {
                {0, 1, 2, 3},
                {1, 0, 6, 4},
                {2, 6, 0, 5},
                {3, 4, 5, 0},
        };
        System.out.println(tsp(graph));
    }

    static int tsp(int[][] g) {
        int m = g.length; // 城市数目
        // 这也说明了 3个城市, 城市1 <=> 001 城市2 <=> 010 城市3 <=> 100 与运算在一起 = (111)2 = (7)10
        // 再加上 0 这个情况，也就是什么城市都不去,原地不动
        // 有 8种组合(2^3) 分别用十进制的0 ~ 7 表示
        // 剩余城市的组合数  2^(m-1)
        int n = 1 << (m - 1);
        int[][] dp = new int[m][n];

        // 填充第0列
        for (int k = 0; k < m; k++) {
            dp[k][0] = g[k][0];
        }
        print(dp);

        // 填充后续列
        for (int j = 1; j < n; j++) {
            for (int i = 0; i < m; i++) {
                dp[i][j] = Integer.MAX_VALUE / 2;//初始化
                // 剩余城市集合j已包含出发城市i，不合理
                // 不可以是类似于 d(1,[1]) d(1,[1|2])  d(1,[1|2|3]) ，不可能出发城市和目的城市相同
                if (contains(j, i)) {
                    continue;
                }
                // 填充单元格
                for (int k = 0; k < m; k++) {
                    /**
                     * 只对剩余城市集合j中的所有城市进行处理，k是遍历集合的每个元素
                     * eg:
                     * d(0,[1|2|3])
                     *     => g[0][1] + d(1,[2|3])
                     *     => g[0][2] + d(2,[1|3])
                     *     => g[0][3] + d(3,[1|2])
                     * j = [1|2|3]
                     * 假设遍历到1， => k = 1
                     * 执行g[0][1] + d(1,[2|3]) <=> g[i][k] + dp[k][exclude(j, k)]
                     * exclude([1|2|3], 1) => [2|3]
                     */
                    if (contains(j, k)) {
                        // 每次遍历得到的dp[i][j] 和之前求得的dp[i][j] 比较，哪一个小，用哪一个
                        // 最初的dp[i][j] = Integer.MAX_VALUE / 2;
                        dp[i][j] = Integer.min(dp[i][j], g[i][k] + dp[k][exclude(j, k)]);
                    }
                }
            }
        }
        print(dp);
        return dp[0][n - 1];
    }

    /**
     * <pre>
     * 对于城市1而言，是第1位
     * 那么推得 城市n是集合这个二进制数中的第n位的1 => 1 << (n - 1) =>相当于1向左移动n-1位
     * 已知集合二进制二进制位 = set
     * 那么 也就是说 得到城市n所对应的位就是 set >> (n-1) 向右移动n-1位
     * eg:
     * [2|3] = [010|100]B => (110)B
     * 在该集合中检查城市1是否存在
     * 1.先得到城市的二进制所对应的位,
     *   110 >> (1 - 1) = (110)B
     * 2.再和001做与运算
     *      110
     *      001 &
     *      ----
     *      000
     * 000 => false => 城市1不存在
     * eg:
     * [2|3] = [010|100]B => (110)B
     * 城市2是否存在
     * 1.先得到城市的二进制所对应的位,
     *   110 >> (2 - 1) = (011)B
     * 2.再和集合对应的二进制做与运算
     *      011
     *      001 &
     *      ----
     *      001
     * 001 => true => 城市2存在
     *   城市3是否存在
     * 1.先得到城市的二进制所对应的位,
     *   110 >> (2 - 1) = (001)B
     * 2.再和集合对应的二进制做与运算
     *      001
     *      001 &
     *      ----
     *      001
     * 001 => true => 城市3存在
     * 城市4是否存在
     * 1.先得到城市的二进制所对应的位,
     *   110 >> (3 - 1) = (000)B
     *      000
     *      001 &
     *      ----
     *      000
     * false => true => 城市4不存在
     * </pre>
     */
    static boolean contains(int set, int city) {
        return (set >> (city - 1) & 1) == 1;
    }

    /**
     *<pre>
     * 异或 相同的位 = 0，不同的位 = 1
     * 对于城市1而言，是第1位
     * 那么推得 城市n是集合这个二进制数中的第n位的1 => 1 << (n - 1) =>相当于1向左移动n-1位
     * eg:
     * [1|2|3]D = exclude 1 => 2|3
     * [1|2|3]D = [001|010|100]B => 001 | 010 | 100 = 111
     *      111
     *      001 ^
     *      ----
     *      110   => 2|3
     * eg:
     * [1|2|3]D = exclude 2 => 1|3
     * [1|2|3]D = [001|010|100]B => 001 | 010 | 100 = 111
     *      111
     *      010 ^
     *      ----
     *      101   => 1|3
     *</pre>
     */
    static int exclude(int set, int city) {
        return set ^ (1 << (city - 1));
    }

    static void print(int[][] dist) {
        System.out.println("-------------------------");
        for (int[] row : dist) {
            System.out.println(Arrays.stream(row).boxed()
                    .map(x -> x >= Integer.MAX_VALUE / 2 ? "∞" : String.valueOf(x))
                    .map(s -> String.format("%2s", s))
                    .collect(Collectors.joining(",", "[", "]")));
        }
    }
}
