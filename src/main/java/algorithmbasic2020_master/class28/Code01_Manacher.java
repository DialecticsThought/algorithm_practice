package algorithmbasic2020_master.class28;

/**
 * TODO
 * Manacher算法解决的问题
 * 字符串str中，最长回文子串的长度如何求解?
 * 如何做到时间复杂度0(N)完成?
 * 回文直径
 * eg: a b c 1 2 3 2 1 d e f
 * 1 2 3 2 1 是回文str
 * 回文直径 = 5 回文半径 = (5+1) / 2 = 3
 * 最右回文右边界  初始情况：int R = -1
 * 回文半径数组：
 * 以0位置为中心 向左右2侧扩展 最长回文是......
 * 以1位置为中心 向左右2侧扩展 最长回文是......
 * 以2位置为中心 向左右2侧扩展 最长回文是......
 * ....
 * 上面的答案记录到arr[]中
 * 举例：
 * # 1 # 1 # 2 # 1 # 1 # k ........
 * 0 1 2 3 4 5 6 7 8 9 10 11
 * 不管是哪一个位置为中心 向2侧扩展，只要扩展到最右边界，就记录下来
 * 以1位置为中心 向左右2侧扩展 直到2位置  R = -1 => R = 2 ,C = 1
 * 以2位置为中心 向左右2侧扩展 直到4位置  R = 2 => R = 4 ,C = 2
 * 以3位置为中心 向左右2侧扩展 直到4位置  R =4 不变
 * 以5位置为中心 向左右2侧扩展 直到4位置  R =4 => R = 10 ,C = 5
 * .....
 * <pre>
 * 如果来到i位置
 * 1.R没有把i位置罩住 => R > i 这种情况无法优化
 * eg: # 1 # 2 # 2 初始：R = -1,i = 0
 * 2.R把i位置罩住 => R <= i
 *      eg: # 1 # 2 # 2 # 1 =>  i=3的时候 R = 4
 *     一定是：?  ?  ?  ?  ?   i`是以c位置为中心 i位置对应的位置，L是以c位置为中心 R位置对应的位置
 *       下标:L  i` c  i  R
 *      可能是：?  ?  ?     i和R是同一个位置 ，i`和L是同一个位置
 *            L  c  R
 *            i`    i
 *     还可以在细分,根据i`位置扩展的回文半径再细分,因为记录过再arr[]中
 *    2.1 i`位置为中心2侧扩展的区域在L~R区域里面
 *       eg:
 *           a  b  c  d  c  k  s  t  s  k  c  d  c  b  e
 *           L     (  i` )        c           i        R
 *         这种情况下，i位置不用想2侧扩展了，因为扩展的区域和i`位置的区域相同
 *         以i`位置为中心，向2边扩展得到的区域甲，以i位置为中心，向2侧扩展得到的区域乙，乙和甲长度相同
 *         乙和甲的关系是逆序关系 => 甲因为是回文 ，那么乙也是
 *         甲区域左侧的char是b，右侧的char是k,这2个char不同
 *         因为关于c位置对称，所以甲右侧的char和乙左侧的char是相同的，都是k ==> 同理甲左侧的1个char == 乙右侧的1个char
 *         => 甲和乙是i`和i位置为中心向2侧扩展的最大区域
 *    2.2 i`位置为中心2侧扩展的区域在L~R区域外面
 *       eg: a  b  c  d  e  d  c  b  a  t  s  t  a  b  c  d  e  d  c  f
 *           L`    L     i`          R`    c                 i     R
 *         这种情况下，i位置不用想2侧扩展了，i的回文半径是i~R
 *       类似
 *           (  [  o  ]  )   o   [  o  ]
 *              L  i` L`     c   R` i  R
 *           L和L`分别和i中心对称，R和R`分别和i中心对称
 *       证明R~R`这段是回文
 *       R~R`的子str(称之为甲)对应L~L`的子str(称之为乙)  因为关于c对称
 *       甲和乙是在大的回文串，且与c对称 => 甲和乙是逆序
 *       此外，甲是i`为中心的小回文串 ==> 甲一定是回文 ==> 乙一定是回文
 *       (  a [  o  ] b  )    o    x [  o  ] y ....
 *            L  i` L`        c      R` i  R
 *       把R`左侧的char称为x  R的右侧char称为y
 *       同理L的左侧char称为a  L`的右侧称为b
 *       a和b相同char，因为i`为中心的回文串 保住了a和b
 *       在以c中心的回文串  b == x 因为b与x对称
 *       但是以c为中心的回文串 左边界是L 右边界是R,y是R的右侧一个char ==> x != y
 *    2.3 i`的回文区域的左边界与L重合
 *      类似
 *          (
 *          [  i  )  o    i`  ]
 *          L        c        R
 *       x  [  a  b  c  b  a  s  t  s  a  b  c  b  a  ] y
 *          L        i`          c           i     R
 *      这种情况：i的回文区域大小  == i`的回文区域
 *      此外  i为中心的回文区域的有边界至少是R 可能更右边
 * </pre>
 * 总结：
 * i在R的内部
 * 1.i`的回文区域在L~R内部,那么i的回文半径就是i`的回文半径  且 i`的回文半径 < i到R的距离
 * 2.i的回文区域超出了L~R,那么i的回文半径的有边界就是k => R`__ i __ R 且 i的回文半径 > i到R的距离
 * 3.i的回文区域的左边界是L,那么i的回文半径的左边界至少是k
 */
public class Code01_Manacher {
    /**
     * <pre>
     * 1
     * "121"是奇回文，有确定的轴'2'。
     * "1221"是偶回文，没有确定的轴，回文的虚轴在"22"中间
     * 因为奇回文和偶回文在判断时比较麻烦，所以对 str 进行处理，
     * 把每个字符开头、结尾和中间插入一个特殊字符'#'来得到一个新的字符串数组。
     * 对奇回文来说，不这么处理也能通过扩的方式找到，比如"bcb"，从'c'开始向左右两侧扩出去能找到最大回文。
     * 处理后为"#b#c#b#"，从'c'开始向左右两侧扩出去依然能找到最大回文。
     * 对偶回文来说，不处理而直接通过扩的方式是找不到的，比如"aa"，因为没有确定的轴，但是处理后为"#a#a#"，就可
     * 以通过从中间的'#'扩出去的方式找到最大回文。
     *
     * 2
     * 2.1 数组 pArr。长度与 charArr 长度一样。
     * pArr[i]的意义是以 i 位置上的字符（charArr[i]）作为回文中心的情况下，扩出去得到的最大回文半径是多少
     * 回文半径包括自己
     * eg：#c#a#b#a#c#"来说，pArr[0..9]为[1,2,1,2,1,6,1,2,1,2,1]。
     * str="#c#a#b#a#c#"的length = 10
     * 整个过程就是在从左到右遍历的过程中，依次计算每个位置的最大回文半径值
     *
     * 2.2
     * 整数 pR： 之前遍历的所有字符的所有回文半径中，最右即将到达的位置
     * 整数 index：这个变量表示最近一次更新 pR 时，那个回文中心的位置。
     * eg：#c#a#b#a#c#"来说，
     * 还没遍历之前，pR 初始设置为-1
     * 1.遍历到charArr[0]=='#'
     * 回文半径为 1，所以目前回文半径向右只能扩到位置 0(也就是没有扩) => pR=1，回文半径最右即将到达的位置变为 1
     * charArr[0]时 pR 更新，index 就更新为 0。
     * 2.遍历到charArr[1]=='c'
     * 回文半径为 2，所以位置 1 向右只能扩到位置 2 => pR=3 回文半径最右即将到达的位置变为 3
     * charArr[1]时 pR 更新，index 就更新为 1
     * 3.遍历到charArr[2]=='#'
     * 回文半径为 1，所以位置 2 向右只能扩到位置 2 => pR=3 回文半径最右即将到达的位置不变
     * charArr[1]时 pR 没有更新，index 没有更新
     * 4.遍历到charArr[3]=='a'
     * 回文半径为 2，所以位置 3 向右能扩到位置 4 => pR=5 回文半径最右即将到达的位置变为 5
     * charArr[1]时 pR 更新，index 就更新为 3
     * 5.遍历到charArr[4]=='#'
     * 回文半径为 1，所以位置 4 向右只能扩到位置 4 => pR=5 回文半径最右即将到达的位置不变
     * charArr[1]时 pR 没有更新，index 没有更新
     * 6.遍历到charArr[5]=='b'
     * 回文半径为 6，所以位置 4 向右能扩到位置 10 => pR=11回文半径最右即将到达的位置变为 11 = length + 1
     * charArr[1]时 pR 更新，index 就更新为 5
     * =>
     * 此时已经到达整个字符数组的结尾，所以之后的过程中  pR 将不再变化
     * 之后的过程中，pR 将不再更新，所以 index 将一直是 5
     *
     * 换句话说，pR 就是遍历过的所有字符中向右扩出来的最大右边界。只要右边界更往右，pR 就更新。
     *
     * 3
     * 只要能够从左到右依次算出数组 pArr 每个位置的值，最大的那个值实际上就是处理后的 charArr 中最大的回文半径，
     * 根据最大的回文半径，再对应回原字符串，整个问题就解决了
     * 步骤 3 就是从左到右依次计算出 pArr 数组每个位置的值的过程
     *
     * 1. 假设现在计算到位置 i 的字符 charArr[i]，因为之前0~i-1位置的计算过程中 不断更新pR和index的值，pR和index都是最新的
     * 2. 如果  pR-1 位置没有包住当前的 i 位置 （ -1 的原因 pR 是 回文半径最右即将到达的位置  不是已经到达的位置）
     * eg: #c#a#b#a#c# 当计算位置1的时候 即 charArr[1]=='c'时  pR = 1 ,那么 pR - 1 = 0  没有包住当前位置1
     * 此时 和普通做法一样，从 i 位置字符开始，向左右两侧扩出去检查，此时的扩过程没有获得加速
     * 3. 如果 pR-1 位置包住了当前的 i 位置
     * eg: 如"#c#a#b#a#c#"，计算到 charArr[6...10]时，pR都为 11，此时 pR-1 包住了位置 6~10
     * 这种情况下，检查过程是可以获得优化的
     *
     * eg：
     *  [                                                             ]
     * 左大                           index              i             右大
     *                                                                pR-1
     *
     * 位置 i 是要计算回文半径（pArr[i]）的位置
     * pR-1 位置此时是包住位置 i 的
     * 同时根据 index 的定义 index 是 pR 更新时那个回文中心的位置：
     * 1.如果 pR-1 位置以 index为中心对称
     *      那么 从左大位置到 pR-1 位置一定是以 index 为中心的回文串，我们把这个回文串叫作大回文串，同时把 pR-1 位置称为右大位置。
     *
     * 2.因为 回文半径数组 pArr 是从左到右计算的 => 位置 i 之前的所有位置都已经算过回文半径 ☆☆☆☆☆☆☆☆☆☆☆
     *
     * 3.假设以 i’为中心的最大回文串的左边界和右边界分别记为左小和右小。
     *
     * 4.位置 i 以 index 为中心向左对称过去的位置为 i’，同理 位置 i’的回文半径也是计算过的 ☆☆☆☆☆☆ ,
     *  => 所以通过位置i' 来计算位置 i
     *
     * 那么以 i’为中心的最大回文串大小（pArr[i’]）必然只有三种情况
     * ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓
     * 情况1: i'位置为中心x向2侧扩展的区域 有被 index为中心x向2侧扩展 的区域 完全包裹 ☆☆☆☆☆☆
     * 左小 和 右小 完全在左大和右大内部，即以 i’为中心的最大回文串完全在以 index 为中心的最大回文串的内部
     *  [      a' ?        1        ? b'            b ?        1        ? a     ]
     *           左小      i'      右小                左小'     i      右小'
     * 左大                                index                                右大
     *                                                                         pR-1
     *  a'是 左小 位置的前一个字符，b'是 右小 位置的后一个字符 ☆☆☆☆☆☆
     *  b是 b'以 index为中心的对称字符，a 是 a'以 index 为中心的对称字符。 ☆☆☆☆☆☆
     *  左小' 是 左小 以 index 为中心的对称位置， 右小' 是 右小 以 index 为中心的对称位置。 ☆☆☆☆☆☆
     * 如果处在情况一下，那么以位置 i为中心的最大回文串可以直接确定，就是从右小'到左小'这一段
     * 原因:
     * 左小到右小这一段如果以 index 为回文中心，对应过去就是右小'到左小'这一段，
     * 那么 右小' <-> 左小' 这一段就完全是左小到右小这一段的逆序。
     * 同时有 左小 <-> 右小 这一段又是回文串（以 i’为回文中心），
     * 所以 右小' <->左小' 这一段一定也是回文串
     * =>
     * 也就是说，以位置 i 为中心的最大回文串起码是 右小' <-> 左小' 这一段。
     * 另外，以位置 i’为中心的最大回文串只是 右小' <-> 左小' 这一段，说明 a'!=b'。
     * 那么与 a'相等的 a 也必然不等于与 b'相等的 b，既然 a!=b，说明以位置 i 为中心的最大回文串就是 右小' 到 左小' 这一段，而不会扩得更大
     * "[......]"表示回文串
     *                   i'         index        i
     *                   ↓           ↓           ↓
     *  {    # C [ # a # b # a # ] d # d [ # a # b # a # ] C #    }
     *       ↑     ↑           ↑           ↑           ↑     ↑
     *       ↑    左小         右小         右小'       左小'   ↑
     *     左大                                             右大
     *                                                     pR-1
     *
     * 情况2： i'位置为中心x向2侧扩展的区域 没有被 index为中心x向2侧扩展 的区域 完全包裹 ☆☆☆☆☆☆
     * 左小 和 右小 的左侧部分在 左大 和 右大 的外部，
     * a 是 左大 位置的前一个字符，d 是 右大 位置的后一个字符
     * b 是 左大' 位置的后一个字符，c 是 右大' 位置的前一个字符
     * 左大' 是 左大 以位置 i’ 为中心的对称位置 (不是以位置 i 为中心的对称位置) ☆☆☆☆☆☆☆☆☆☆
     * 右大' 是 右大 以位置 i 为中心的对称位置 (不是以位置 i’ 为中心的对称位置) ☆☆☆☆☆☆☆☆☆☆
     *            i'            index          i
     *            ↓              ↓             ↓
     *  { a [ ?   1   ? ] b           c [ ?   1   ? ] d    }
     *    ↑   ↑       ↑   ↑                ↑       ↑
     *    ↑   ↑       ↑   ↑                ↑       ↑
     *    ↑  左大    左大'  ↑               右大'    右大
     *   左小             右小
     *
     * 如果处在情况2下，那么以位置 i 为中心的最大回文串可以直接确定，就是从 右大' 到 右大 这一段
     * 原因：
     * 1.
     * 首先 左大 <-> 左大' 这一段和 右大' <-> 右大 这一段是关于 index 对称的，
     * 所以 右大' <-> 右大 这一段是 左大 <-> 左大'这一段的逆序
     * 2.
     * 同时 左小 <-> 右小 这一段是回文串（以i’位置为中心），
     * 那么 左大 <-> 左大' 这一段也是回文串，
     * 左大 <-> 左大' 这一段的逆序也是回文串, ==> 右大' <-> 右大 这一段一定是回文串
     * 也就是说，以位置 i 为中心的最大回文串起码是右大'到右大这一段
     * 3.
     * 另外，左小 <-> 右小这一段是回文串，说明 a==b，
     * b 和 c 关于 index 对称说明 b==c，
     * 左大 <-> 右大 这一段没有扩得更大，说明 a!=d，所以 d!=c
     * 说明以位置 i 为中心的最大回文串就是 右大' <-> 右大 这一段，而不会扩得更大
     * eg:
     *           i'         index        i
     *           ↓           ↓           ↓
     *  #  a  #  b  #  a  #  c  #  a  #  b  #  d   #
     *  ↑     ↑     ↑     ↑           ↑     ↑
     *  ↑    左大   左大'   ↑         右大'  右大
     * 左小               右小
     *
     * TODO
     * 情况3： i'位置为中心x向2侧扩展的区域 没有被 index为中心x向2侧扩展 的区域 完全包裹  + 2个区域的左边界重合 ☆☆☆☆☆☆
     * 左小 和 左大 是同一个位置，即以 i’为中心的最大回文串压在了以 index 为中心的最大回文串的边界上
     * 左大 与 左小 的位置重叠， 右小' 是 右小 位置以 index 为中心的对称位置，
     * 右大' 是 右大 位置以 i 为中心的对称位置，可以很容易证明 右小' 和 右大' 位置也重叠。
     * (不同于情况2 ， 左大' 是 左大 以位置 i’ 为中心的对称位置  没有 用到)
     *                         index
     *                          ↓
     *  {     [    i'   ]              [    i    ]     }
     *        ↑         ↑               ↑         ↑
     *        ↑        右小              ↑        右大
     *     左大 左小                  右小' 右大'
     * 如果处在情况3下，那么以位置 i 为中心的最大回文串起码是 右大' 和 右大 这一段，但可能会扩得更大。
     * 因为 右大' 和 右大 这一段是左小和右小这一段以 index 为中心对称过去的，所以两段互为逆序关系
     * 同时 左小 和 右小 这一段又是回文串，所以 右大' 和 右大 这一段肯定是回文串，
     * 但以位置 i 为中心的最大回文串是可能扩得更大的
     *                   i'         index        i
     *                   ↓           ↓           ↓
     *   #   d  #  a  #  b  #  a  #  c  #  a  #  b  #  a  #  c  #   (这里 右大' <-> 右大 可以再扩大,但是 左大 <-> 右大 不能扩)
     *          ↑                 ↑     ↑                 ↑
     *         左大              右小   右小'              右大
     *         左小                    右大'
     *
     *
     * 4．按照步骤 3 的逻辑从左到右计算出 pArr 数组，计算完成后再遍历一遍 pArr 数组，找出
     * 最大的回文半径，假设位置 i 的回文半径最大，即 pArr[i]==max。但 max 只是 charArr 的最大回
     * 文半径，还得对应回原来的字符串，求出最大回文半径的长度（其实就是 max-1）。比如原字符
     * 串为"121"，处理成 charArr 之后为"#1#2#1#"。在 charArr 中位置 3 的回文半径最大，最大值为 4
     * （即 pArr[3]==4），对应原字符串的最大回文子串长度为 4-1=3。
     *
     *
     * </pre>
     *
     * @param s
     * @return
     */
    public static int manacher(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        // "12132" -> "#1#2#1#3#2#"
        char[] str = manacherString(s);
        // 回文半径的大小
        int[] pArr = new int[str.length];
        int C = -1;
        /**
         *TODO
         * R的区别
         * 讲述中：R代表最右的扩成功的位置
         * coding：最右的扩成功位置的，再下一个位置
         * */
        int R = -1;
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < str.length; i++) { // 0 1 2
            /*
             *TODO
             * 现在R第一个违规的位置，那么就是i>= R ，R在i外部
             * R > i 才称之为R在i内部
             * i位置扩出来的答案，i位置扩的区域，至少是多大。
             * */
            if (R > i) {
                /**
                 *TODO
                 * 2 * C - i 就是i'
                 * i'的回文半径长度 和R到i的距离 哪个区域小 哪个区域就是不用校验的区域
                 *TODO i在R内部的话 3种情况
                 * i'的回文区域在L~R内 => i的回文半径 就是 i'的回文区域 并且i'的回文区域长度 < R-i的距离
                 * i'的回文区域在L~R外 => i的回文半径 的右边界 就是R本身 并且i'的回文区域长度 > R-i的距离
                 * i'的回文区域的左边界就是L => i的回文半径 的右边界 至少是R（不确定） R的右侧还要检测
                 * */
                pArr[i] = Math.min(pArr[2 * C - i], R - i);
            } else {
                // 至少的回文半径长度是1
                pArr[i] = 1;
            }
            //pArr[i] = R > i ? Math.min(pArr[2 * C - i], R - i) : 1;
            /**
             *TODO
             * i+不用检验的区域 不越界
             * i-不用检验的区域 不越界
             * */
            while (i + pArr[i] < str.length && i - pArr[i] > -1) {// 右边要验证的字符和左边要验证的字符不能越界
                //如果 再往右的char ==  再往左的char
                if (str[i + pArr[i]] == str[i - pArr[i]])
                    //回文半径++
                    pArr[i]++;
                else {
                    //失败
                    break;
                }
            }
            if (i + pArr[i] > R) {//如果更往右了
                //更新R和C
                R = i + pArr[i];
                C = i;
            }
            max = Math.max(max, pArr[i]);
        }
        //回文半径-1就是原始str的最大回文子串长度
        return max - 1;
    }

    public static char[] manacherString(String str) {
        char[] charArr = str.toCharArray();
        char[] res = new char[str.length() * 2 + 1];
        int index = 0;
        for (int i = 0; i != res.length; i++) {
            res[i] = (i & 1) == 0 ? '#' : charArr[index++];
        }
        return res;
    }

    // for test
    public static int right(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        char[] str = manacherString(s);
        int max = 0;
        for (int i = 0; i < str.length; i++) {
            int L = i - 1;
            int R = i + 1;
            while (L >= 0 && R < str.length && str[L] == str[R]) {
                L--;
                R++;
            }
            max = Math.max(max, R - L - 1);
        }
        return max / 2;
    }

    // for test
    public static String getRandomString(int possibilities, int size) {
        char[] ans = new char[(int) (Math.random() * size) + 1];
        for (int i = 0; i < ans.length; i++) {
            ans[i] = (char) ((int) (Math.random() * possibilities) + 'a');
        }
        return String.valueOf(ans);
    }

    public static void main(String[] args) {
        int possibilities = 5;
        int strSize = 20;
        int testTimes = 5000000;
        System.out.println("test begin");
        for (int i = 0; i < testTimes; i++) {
            String str = getRandomString(possibilities, strSize);
            if (manacher(str) != right(str)) {
                System.out.println("Oops!");
            }
        }
        System.out.println("test finish");
    }

}
