package code_for_great_offer.class36;

import java.util.HashMap;

// 来自京东
// 把一个01字符串切成多个部分，要求每一部分的0和1比例一样，同时要求尽可能多的划分
// 比如 : 01010101
// 01 01 01 01 这是一种切法，0和1比例为 1 : 1
// 0101 0101 也是一种切法，0和1比例为 1 : 1
// 两种切法都符合要求，但是那么尽可能多的划分为第一种切法，部分数为4
// 比如 : 00001111
// 只有一种切法就是00001111整体作为一块，那么尽可能多的划分，部分数为1
// 给定一个01字符串str，假设长度为N，要求返回一个长度为N的数组ans
// 其中ans[i] = str[0]~str[i]这个前缀串，要求每一部分的0和1比例一样，同时要求尽可能多的划分下，部分数是多少
// 输入: str = "010100001"
// 输出: ans = [1, 1, 1, 2, 1, 2, 1, 1, 3]
public class Code02_Ratio01Split {
	/*
	*TODO
	* 假设来到100位置 那么0~99范围上 0和1的比例是3:7
	* 如果 有一种划分是等比例的话 那么部分的比例和整体的比例是3:7
	* 如果 0~99范围上 0和1的比例是3:7 假设  0~89范围上 0和1的比例是3:7
	* 那么能切成2部分  0~89 90~99
	* 如果 0~69范围上 0和1的比例也是3:7
	* 那么 能切成3部分  0~69 70~89 90~99
	* .....
	* 说明前缀有多少个3:7 再加上自己 就是总共的
	*TODO
	* str = "010100001"
	* 0和1的比例是2:1
	* 0~0 范围 划分方法只有1 因为只有0
	* 0~1 范围 划分方法只有1 1和0的个数比例 是1:1
	*
	*TODO
	* 那么就是收集0的个数 1的个数
	* 再得到最大公约数
	* 有一张表  key是分子表 value是分母表
	* 类似于 leetcode求最大共线问题
	 * */
	// 001010010100...
	public static int[] split(int[] arr) {

		// key : 分子
		// value : 属于key的分母表, 每一个分母，及其 分子/分母 这个比例，多少个前缀拥有
		HashMap<Integer, HashMap<Integer, Integer>> pre = new HashMap<>();
		int n = arr.length;
		int[] ans = new int[n];
		int zero = 0; // 0出现的次数
		int one = 0; // 1出现的次数
		/*
		 *TODO
		 * int[] arr = { 0, 1, 0, 1, 0, 1, 1, 0 };
		 * 来到1位置
		 * 	0~1范围不全是0或者1  0的个数 = 1  1的个数 = 1
		 * 	求出 0的个数/1的个数的最简形式  更新 这个0的个数/1的个数的最简形式 1 / 1 出现的次数 = 1
		 * 来到2位置
		 * 	0~2范围不全是0或者1  0的个数 = 2  1的个数 = 1
		 *  求出 0的个数/1的个数的最简形式  更新 这个0的个数/1的个数的最简形式 2 / 1 出现的次数 = 1
		 * 来到3位置
		 * 	0~3范围不全是0或者1  0的个数 = 2  1的个数 = 2
		 *  求出 0的个数/1的个数的最简形式  更新 这个0的个数/1的个数的最简形式 1 / 1 出现的次数 = 2
		 * 来到4位置
		 * 0~4范围不全是0或者1  0的个数 = 3  1的个数 = 2
		 *  求出 0的个数/1的个数的最简形式  更新 这个0的个数/1的个数的最简形式 3 / 2 出现的次数 = 1
		 * 来到5位置
		 * 0~5范围不全是0或者1  0的个数 = 3  1的个数 = 3
		 *  求出 0的个数/1的个数的最简形式  更新 这个0的个数/1的个数的最简形式 1 / 1 出现的次数 = 3
		 * 来到6位置
		 *	 0~6范围不全是0或者1  0的个数 = 3  1的个数 = 4
		 *   求出 0的个数/1的个数的最简形式  更新 这个0的个数/1的个数的最简形式 3 / 4 出现的次数 = 1
		 * 来到7位置
		 * 	 0~67范围不全是0或者1  0的个数 = 4  1的个数 = 4
		 *   求出 0的个数/1的个数的最简形式  更新 这个0的个数/1的个数的最简形式 1 / 1 出现的次数 = 4
		 * ans
		 * =>1 1 1 2 1 3 1 4
		 * */
		for (int i = 0; i < n; i++) {
			//TODO  来到当前位置 更新 0~i范围 0的个数 和 1的个数
			if (arr[i] == 0) {
				zero++;//0的个数++
			} else {
				one++;//1的个数++
			}
			/*
			*TODO
			* 0~i范围 全是0或全是1
			* 那么每一个数单独称为一个部分 也就是i+1份
			* */
			if (zero == 0 || one == 0) {
 				ans[i] = i + 1;
			} else { // 0和1，都有数量 -> 最简分数
				int gcd = gcd(zero, one);
				/*
				*TODO
				* 0~i范围 0与1的个数比例是多少
				* 然后判断 这个比例 有多少个前缀拥有
				* 如果之前有3个前缀拥有 就是4份
				* 分子与分母可能不是最简的 所以 需要化简再相除 也就是a/b
				 * */
				int a = zero / gcd;
				int b = one / gcd;
				if (!pre.containsKey(a)) {
					//TODO 这个新的分子
					pre.put(a, new HashMap<>());
				}
				if (!pre.get(a).containsKey(b)) {
					//TODO 这个新的分母 以及 这个分子/分母 出现的次数
					pre.get(a).put(b, 1);
				} else {
					//TODO 这个新的分母 以及 这个分子/分母 出现的次数
					pre.get(a).put(b, pre.get(a).get(b) + 1);
				}
				ans[i] = pre.get(a).get(b);
			}
		}
		return ans;
	}

	public static int gcd(int m, int n) {
		return n == 0 ? m : gcd(n, m % n);
	}

	public static void main(String[] args) {
		int[] arr = { 0, 1, 0, 1, 0, 1, 1, 0 };
		int[] ans = split(arr);
		for (int i = 0; i < ans.length; i++) {
			System.out.print(ans[i] + " ");
		}
	}

}
