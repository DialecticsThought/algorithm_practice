package code_for_great_offer.class45;

import java.util.Arrays;


/*
*TODO
* 来自京东笔试
* 小明手中有n块积木，并且小明知道每块积木的重量。现在小明希望将这些积木堆起来
* 要求是任意一块积木如果想堆在另一块积木上面，那么要求：
* 1) 上面的积木重量不能小于下面的积木重量
* 2) 上面积木的重量减去下面积木的重量不能超过x
* 3) 每堆中最下面的积木没有重量要求
* 现在小明有一个机会，除了这n块积木，还可以获得k块任意重量的积木。 这块可以变成任何重量
* 小明希望将积木堆在一起，同时希望积木堆的数量越少越好，你能帮他找到最好的方案么？
* 输入描述:
* 第一行三个整数n,k,x，1<=n<=200000，0<=x,k<=1000000000
* 第二行n个整数，表示积木的重量，任意整数范围都在[1,1000000000]
* 样例输出：
* 13 1 38
* 20 20 80 70 70 70 420 5 1 5 1 60 90
* 1 1 5 5 20 20 60 70 70 70 80 90 420 -> 只有1块魔法积木，x = 38
* 输出：2
* 解释：
* 两堆分别是
* 1.  1 1 5 5 20 20 (50) 这是魔法积木
* 60 70 70 70 80 90
* 2.  420
* 其中x是一个任意重量的积木，夹在20和60之间可以让积木继续往上搭
*TODO
* 第一个贪心: 从小到大排序 不超过差值的积木放在一个堆里面
* eg: 1 1 3 5 10 14 16 27 29 45 48 51 67 x=4
* 5个堆 在没有魔法积木的情况下
* 1 1 3 5
* 10 14 16
* 27 29
* 45 48 51
* 67
* 想让第1个和第2个合在一起 需要解决5的差值
* 想让第2个和第3个合在一起 需要解决11的差值
* 想让第3个和第4个合在一起 需要解决16的差值
* 想让第4个和第5个合在一起 需要解决16的差值
* 第二个贪心: 差值越小，越优先去解决，通过魔法积木
* */
public class Code01_SplitBuildingBlock {

	/**
	 * 这是启发解
	 * arr是从小到大排序的，x是限制，固定参数
	 * 当前来到i位置，积木重量arr[i]
	 * 潜台词 : 当前i位置的积木在一个堆里，堆的开头在哪？之前已经决定了
	 * i i+1 该在一起 or 该用魔法积木弥合 or 该分家
	 *  返回值：arr[i....]最少能分几个堆？
	 * @param arr
	 * @param x
	 * @param i
	 * @param r
	 * @return
	 */
	public static int zuo(int[] arr, int x, int i, int r) {
		if (i == arr.length - 1) {
			return 1;
		}
		// i没到最后一个数
		if (arr[i + 1] - arr[i] <= x) { // 一定贴在一起
			return zuo(arr, x, i + 1, r);
		} else { // 合并！分家
			// 分家
			int p1 = 1 + zuo(arr, x, i + 1, r);
			// 合并
			int p2 = Integer.MAX_VALUE;
			int need = (arr[i + 1] - arr[i] - 1) / x;
			if (r >= need) {
				p2 = zuo(arr, x, i + 1, r - need);
			}
			return Math.min(p1, p2);
		}
	}

	/**
	* TODO
	* 这是最优解
	* arr里装着所有积木的重量
	* k是魔法积木的数量，每一块魔法积木都能变成任何重量
	* x差值，后 - 前 <= x
	* */
	public static int minSplit(int[] arr, int k, int x) {
		Arrays.sort(arr);
		int n = arr.length;
		/*
		*TODO
		* 这个数组 存放的是需要合并的差值
		* 第一个贪心: 从小到大排序 不超过差值的积木放在一个堆里面
		* eg: 1 1 3 5 10 14 16 27 29 45 48 51 67 x=4
		* 5个堆 在没有魔法积木的情况下
		* 1 1 3 5
		* 10 14 16
		* 27 29
		* 45 48 51
		* 67
		* 想让第1个和第2个合在一起 需要解决5的差值
		* 想让第2个和第3个合在一起 需要解决11的差值
		* 想让第3个和第4个合在一起 需要解决16的差值
		* 想让第4个和第5个合在一起 需要解决16的差值
		* 第二个贪心: 差值越小，越优先去解决，通过魔法积木
		* needs[5 11 16 16]
		* eg2:
		* [1 1 9 10 13 29...] x=5
		* 来到0位置 堆数量=1
		* 来到1位置， [1]-[0]<x，堆数量=不变
		* 来到2位置， [2]-[1]>x，堆数量=+1  needs记录差值
		* 来到3位置， [3]-[2]<x，堆数量=不变
		* 来到4位置， [4]-[3]<x，堆数量=不变
		* 来到5位置， [5]-[4]>x，堆数量=+1  needs记录差值
		* .....
		*TODO
		* size是记录needs的最后一个元素的位置
		* */
		int[] needs = new int[n];
		int size = 0;
		int splits = 1;
		//TODO 下面的for循环 初步 算出堆的数量
		for (int i = 1; i < n; i++) {
			if (arr[i] - arr[i - 1] > x) {
				needs[size++] = arr[i] - arr[i - 1];
				splits++;
			}
		}
		if (splits == 1 || x == 0 || k == 0) {
			return splits;
		}
		//TODO 试图去利用魔法积木，合并堆！
		Arrays.sort(needs, 0, size);
		/*
		*TODO
		* eg: x=5 需要合并的差值一定>=5
		* 上一个堆的最后元素=70 下一个堆的开始元素=90
		* 需要几个魔法积木? 3块 75 80 85
		* 上一个堆的最后元素=70 下一个堆的开始元素=91
		* 需要几个魔法积木? 4块 75 80 85 90
		* 也就是 ((91-70)-x)/x 再向上取整
		* 技巧：(a/b)向上取整 = (a+b-1)/b向下取整
		* */
		for (int i = 0; i < size; i++) {
			int need = (needs[i] - 1) / x;
			if (k >= need) {
				splits--;
				k -= need;
			} else {
				break;
			}
		}
		return splits;
	}

}
