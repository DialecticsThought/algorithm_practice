package code_for_great_offer.class48;

/**
 *TODO
 * 以字符串的形式给出 n , 以字符串的形式返回 n 的最小 好进制  。
 * 如果 n 的  k(k>=2) 进制数的所有数位全为1，则称 k(k>=2) 是 n 的一个 好进制 。
 * 示例 1：
 * 输入：n = "13"
 * 输出："3"
 * 解释：13 的 3 进制是 111。
 * 示例 2：
 * 输入：n = "4681"
 * 输出："8"
 * 解释：4681 的 8 进制是 11111。
 * 示例 3：
 * 输入：n = "1000000000000000000"
 * 输出："999999999999999999"
 * 解释：1000000000000000000 的 999999999999999999 进制是 11。
 *TODO
 * 对于任何一个数x，有x-1进制是好进制
 * eg: 10 对于9进制而言就是11  那么久是好进制
 * 但是要找的是最小的
 *TODO
 *  利用二分
 *TODO
 * 1.先把某些数字 明显是以2进制为好进制的剔除掉   eg: 15  7  31  也就是x == 2^n - 1
 * 2.x != 2^n - 1 查看x在2进制的位数m, 说明2进制不是好进制
 * 3.这个x必须以m位的情况下，最小的好二进制是什么
 *    找到
 *    没找到
 *      这个x必须以m-1位的情况下，最小的好二进制是什么
 *       找到
 *       没找到
 *         这个x必须以m-2位的情况下，最小的好二进制是什么
 *           找到
 *           没找到
 *    ....
 *    直到这个x必须以3位的情况下，最小的好二进制是什么
 *TODO
 * 对于这个x必须以m位的情况下，最小的好二进制是什么 这个问题
 * 假设有一个数x，这个数必须有5位，再假设有一个k进制
 * 进制数小意味着有更多个位数
 * 进制数大意味着有更少个位数
 * 当k这个数低到什么程度就会超过5位，也就是当k^5 <= x的时候，这个时候一定会动用第6位  => k <= x ^ (1/5) 并 向下取整  = a
 * _ _ _ _ _ _ => k^5,k^4,k^3,k^2,k^1,k^0 因为k^4+k^3+k^2+k^1+k^0 <=k^5 并且 k^5 <= x 那么说明要6位
 * 当k这个数高到什么程度就会少过5位，也就是当k^5 >= x的时候，这个时候一定会只动用第4位 => k <= x ^ (1/4) 并 向上取整 = b
 * _ _ _ _ _  => k^4,k^3,k^2,k^1,k^0 并且 k^4 > x 那么说明只要4位
 * 所以在 [a,b]范围 找到具体最小的好进制
 * 利用二分
 * 假设[a,b] = [7,23]  (7+23) /2 = 15
 * 15进制的话 如果有一个数 这5个位每个都是1的话 再转成10进制后 y ，x和y的关系
 * y > x 在[7,14]范围
 * y < x 在[16,23]范围
 * y == x 那么就是15进制
 */
public class LeetCode_0483_SmallestGoodBase {

    // ""4651" -> 4651
    public static String smallestGoodBase(String n) {
        long num = Long.valueOf(n);
        /**
         * n这个数，需要从m位开始试，固定位数，一定要有m位！
         * Math.log(n)  = log10(n)
         * log2(n) = log10(n)/log10(2) = Math.log(n) /Math.log(2)
         * x == 2^n-1  假设是17位 就从17位开始算
         * x!=2^n-1 假设是17位 就从16位开始算 因为肯定不是2进制实时好进制
         */
        for (int m = (int) (Math.log(num + 1) / Math.log(2)); m > 2; m--) {
            // num开m次方
            long l = (long) (Math.pow(num, 1.0 / m));//范围的左边界
            long r = (long) (Math.pow(num, 1.0 / (m - 1))) + 1L;//范围的右边界
            while (l <= r) {//范围里面做二分
                //中点
                long k = l + ((r - l) >> 1);
                long sum = 0L;
                long base = 1L;
                // 当前是k进制 一共m位，每一位都是1的情况下的10进制数和当前
                for (int i = 0; i < m && sum <= num; i++) {
                    sum += base;
                    base *= k;
                }
                if (sum < num) {
                    l = k + 1;
                } else if (sum > num) {
                    r = k - 1;
                } else {
                    return String.valueOf(k);
                }
            }
        }
        return String.valueOf(num - 1);
    }

}
