package code_for_great_offer.class49;

/*
* 这道题在leetcode上，所有题解都只能做到O( (logN) 平方)的解
* 我们课上讲的是O(logN)的解
* 打败所有题解
* eg: n=672
* =>
* [1,10,100~109,11,110~119....]
*TODO
* 什么是数量 什么是顺序
* 以x开头 一共只有1位的 数量多少?
* 只有一个 就是x自己
* 以x开头 小于等于2位的 数量多少?
* 11个 x自己 + x0~x9  这是数量 不是顺序
* 以x开头 小于等于3位的 数量多少?
* 111个 x自己 + x0~x9 + x00~x99 这是数量 不是顺序
* ....
* 以x开头 小于等于n位的 数量多少?
* 111..1111 一共n个1
* eg: 65327
* 那么
* 左侧
* 就要找 1开头小于等于5位的 数量是11111个
* 就要找 2开头小于等于5位的 数量是11111个
* 就要找 3开头小于等于5位的 数量是11111个
* 就要找 4开头小于等于5位的 数量是11111个
* 就要找 5开头小于等于5位的 数量是11111个
* 右侧
* 就要找 7开头小于等于4位的 数量是1111个
* 就要找 8开头小于等于4位的 数量是1111个
* 就要找 9开头小于等于4位的 数量是1111个
* 中间
* 以6开头 小于等于4位的 数量多少 也就是1111个
* 以6开头 等于5位的 数量多少 也就是60000~65327这范围
*TODO
* eg：1~65237 范围 返回 这个范围字典序排序后的第100个数
* 查看 这个数是否来自于左侧 中间 还是右侧
* 左侧总共 有数量11111*5=55555
* 因为题目要求是找第100个数 一定在左侧
* */
public class LeetCode_0440_KthSmallestInLexicographicalOrder {
	//TODO 第0位没有用 用来提取开头的数  eg: 65237 的"6"提取出来
	public static int[] offset = { 0, 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };
	//TODO 第0位没有用 某一个开头为x的数字 <=k位的数量有多少  那就是11...11 一共k个1
	public static int[] number = { 0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111 };

	public static int findKthNumber(int n, int k) {
		/*
		* 数字num，有几位，len位
		* 65237, 5位，len = 5
		* */
		int len = len(n);
		//TODO 65237, 开头数字 first = 6
		int first = n / offset[len];
		/*
		*TODO
		* 65237，左边有几个数字？
		* 就要找 1开头小于等于5位的 数量是11111
		* 就要找 2开头小于等于5位的 数量是11111
		* 就要找 3开头小于等于5位的 数量是11111
		* 就要找 4开头小于等于5位的 数量是11111
		* 就要找 5开头小于等于5位的 数量是11111
		* 5 * 11111
		* */
		int left = (first - 1) * number[len];
		int pick = 0;
		int already = 0;
		if (k <= left) { //TODO 直接在左侧找
			/*
			*TODO k / a 向上取整-> (k + a - 1) / a
			* eg: num=65237 现在找字典序排序后第43210个数
			* 知道左侧有55555个
			* 来自于左侧谁开头的呢？
			* 一定是4开头的某一个数
			* 因为
			* 1开头小于等于5位的 数量是11111
			* 2开头小于等于5位的 数量是11111
			* 3开头小于等于5位的 数量是11111
			* 4开头小于等于5位的 数量是11111
			* 一共44444个 超过了 43210的范围
			* 43210/11111=3.几  再向上取整 = 4 知道了第一位是谁
			* 要找到43210是4开头的第几个 那么就是第(43210-33333)个
			* */
			pick = (k + number[len] - 1) / number[len];
			already = (pick - 1) * number[len];
			return kth((pick + 1) * offset[len] - 1, len, k - already);
		}
		/*
		*TODO 65237 中间有几个
		* 1111+5237+1
		* 因为
		* 以6开头 小于等于4位的 数量多少 也就是1111个
		* 以6开头 等于5位的 数量多少 也就是60000~65327 = 5238个
		* */
		int mid = number[len - 1] + (n % offset[len]) + 1;
		if (k - left <= mid) {//TODO 在中间找
			return kth(n, len, k - left);
		}
		//TODO 在右侧找
		k -= left + mid;
		len--;
		pick = (k + number[len] - 1) / number[len] + first;
		already = (pick - first - 1) * number[len];
		return kth((pick + 1) * offset[len] - 1, len, k - already);
	}

	public static int len(int n) {
		int len = 0;
		while (n != 0) {
			n /= 10;
			len++;
		}
		return len;
	}
	/*
	*TODO 确定顺序问题
	* 有一个函数 eg:f(653,3,k) k指的是顺序上653是第几个
	* 函数意思是
	* 必须6开头 且 小于等于3位 的数字,这些数字必须<=653
	* 在上面的范围的数字中 从顺序角度看，第k个数是什么
	* f(74216,5,k) 函数意思：
	* 7开头 小于等于5位的全体数字 并且 这些数字 必须 小于 74216
	* eg: k=32492 而且数字来自于左侧 且 开头的数字是3
	* 那么需要调用f(39999,5,k)
	* 因为来自于左侧 且 开头的数字是3的限制是39999
	* 又因为不来自于中间，所以传的不是n
	* 同理 来自于右侧 也是这样
	* 如果来自于中间 eg：65237 那么就是f(65237,5,k)
	* eg:
	* f(65237,5,23014)
	* 6开头 小于等于5位的全体数字 并且 这些数字 必须 小于 65237，在上面的范围的数字中 从顺序角度看，第23014个数是什么
	* 如果就1位数，那么 就是数字6 他是顺序上第一个
	*	排除完上面的数字的时候，调用递归f(65237,5,23013)
	* 6开头的情况下 下一位是0的数字(包含了这个0)还有4位 类似于60XXXX
	* 	那么61开头的情况下 <=4位(包含了这个1)的数字有几个
	* 	那么62开头的情况下 <=4(包含了这个2)位的数字有几个
	* 	那么63开头的情况下 <=4(包含了这个3)位的数字有几个
	* 	那么64开头的情况下 <=4(包含了这个4)位的数字有几个
	* 到了最高位开始数的第2位是5的情况下 也就是65XXXX 会有个断层 也就是中间
	* 		那么65开头的情况下 <=4(包含了这个5)位的数字有几个
	* 到了右侧
	* 就要找 66开头的情况下 <=3位(包含了这个6)的 数字有几个
	* 就要找 67开头的情况下 <=3位(包含了这个7)的 数字有几个
	* 就要找 68开头的情况下 <=3位(包含了这个8)的 数字有几个
	* 就要找 69开头的情况下 <=3位(包含了这个9)的 数字有几个
	* 和主流程类似 主流程不能0开头 而这个函数 开头数字是存在的
	*TODO
	* 如果命中了左侧或者右侧 那么和原始数字max无关了
	* 如果命中 了中间 还是受限制 继续递归 分左中右3个部分
	* */
	public static int kth(int max, int len, int kth) {
		/*
		*TODO closeToMax意思
		* 中间范围还管不管的着！
		* 有任何一步，中间位置没命中，左或者右命中了，那以后就都管不着了！
		* 但是开始时，肯定是管的着的！
		* */
		boolean closeToMax = true;
		int ans = max / offset[len];
		while (--kth > 0) {
			max %= offset[len--];
			int pick = 0;
			//TODO 一旦发现 中间的位置不再管了 也就是左侧 或者右侧 之后都会执行这个
			if (!closeToMax) {
				//TODO 定位下去 每一位取什么数字 选出来
				pick = (kth - 1) / number[len];
				ans = ans * 10 + pick;
				kth -= pick * number[len];
			} else {//TODO 这个else分支就是上一轮命中中间的情况
				//TODO 命中左侧
				int first = max / offset[len];
				int left = first * number[len];
				if (kth <= left) {
					closeToMax = false;
					pick = (kth - 1) / number[len];
					ans = ans * 10 + pick;
					kth -= pick * number[len];
					continue;
				}
				//TODO 命中中间 中间的位置可能不变
				kth -= left;
				int mid = number[len - 1] + (max % offset[len]) + 1;
				if (kth <= mid) {
					ans = ans * 10 + first;
					continue;
				}
				//TODO 命中右侧 中间的位置以后管不着
				closeToMax = false;
				kth -= mid;
				len--;
				pick = (kth + number[len] - 1) / number[len] + first;
				ans = ans * 10 + pick;
				kth -= (pick - first - 1) * number[len];
			}
		}
		return ans;
	}

}
