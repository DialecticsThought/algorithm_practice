package code_for_great_offer.class32;

/*
*TODO
* 颠倒给定的 32 位无符号整数的二进制位。
* 提示：
* 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，
* 并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
* 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2中，输入表示有符号整数 -3，
* 输出表示有符号整数 -1073741825。
* 示例 1：
* 输入：n = 00000010100101000001111010011100
* 输出：964176192 (00111001011110000010100101000000)
* 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
*      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
* 示例 2：
* 输入：n = 11111111111111111111111111111101
* 输出：3221225471 (10111111111111111111111111111111)
* 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
    因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
链接：https:*leetcode.cn/problems/reverse-bits
*
* */
public class LeetCode_0190_ReverseBits {
	/*
	*TODO
	* 代码看着很魔幻吧？
	* 给个例子，假设n二进制为：
	* 1011 0111 0011 1001 0011 1111 0110 1010
	* 解释一下，第一行，是把n左边16位，和n右边16位交换
	* n = (n >>> 16) | (n << 16);
	* 因为 n >>> 16 就是左边16位被移动到了右侧
	* 同时 n << 16  就是右边16位被移动到了左侧
	* 又 | 在了一起，所以，n变成了
	* 0011 1111 0110 1010 1011 0111 0011 1001
	*TODO
	* 第二行，
	* n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
	* (n & 0xff00ff00)
	* 这一句意思是，左侧开始算0~7位，保留；8~15位，全变0；16~23位，保留；24~31位，全变0
	* 0011 1111 0000 0000 1011 0111 0000 0000
	* (n & 0xff00ff00) >>> 8 这句就是上面的值，统一向右移动8位，变成：
	* 0000 0000 0011 1111 0000 0000 1011 0111
	*
	*TODO
	* (n & 0x00ff00ff)
	* 这一句意思是，左侧开始算0~7位，全变0；8~15位，保留；16~23位，全变0；24~31位，保留
	* 0000 0000 0110 1010 0000 0000 0011 1001
	* (n & 0x00ff00ff) << 8 这句就是上面的值，统一向左移动8位，变成：
	* 0110 1010 0000 0000 0011 1001 0000 0000
	* 那么 ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8)
	* 什么效果？就是n的0~7位和8~15位交换了，16~23位和24~31位交换了
	* 0110 1010 0011 1111 0011 1001 1011 0111
	* 也就是说，整个过程是n的左16位，和右16位交换
	* n的左16位的内部，左8位和右8位交换；n的右16位的内部，左8位和右8位交换
	* 接下来的一行，其实是，从左边开始算，0~7位内部，左4和右4交换；8~15位，左4和右4交换；...
	* 接下来的一行，其实是，从左边开始算，0~3位内部，左2和右2交换；4~7位，左2和右2交换；...
	* 最后的一行，其实是，从左边开始算，0~1位内部，左1和右1交换；2~3位，左1和右1交换；...
	 */
	public static int reverseBits(int n) {
		/*
		*TODO
		* n >>> 16 n不带符号 右移 16位 那么高位的16位数字 变成低位的16  高位的16位个数字全是0
		* n << 16  n带符号 右移 16位	那么低位的16数字 变成高位的16
		* => n的高16位，和n的低16位，交换
		* 第2步 高位的16位为一组   前8位和后 8位交换  低位的16位为一组  前8位和后 8位交换
		* 0xff00ff00 => 1111 1111 0000 0000 1111 1111 0000 0000
		* 0x00ff00ff => 0000 0000 1111 1111 0000 0000 1111 1111
		* 32位 每8位一组 那么可以抽象成 ___ ___ ___ ___
		* (n & 0xff00ff00) >>> 8 可以实现 _√_ _0_ _√_ _0_ ("_√_" 表示保留 原有8位 "_0_"表示8位全是0)
		* (n & 0x00ff00ff) << 8 可以实现 _0_ _√_  _0_ _√_  ("_√_" 表示保留 原有8位 "_0_"表示8位全是0)
		* 第3步 每8位一组 一组内 前4位和 后4位交换
		* 0xf0f0f0f0 => 1111 0000 1111 0000 1111 0000 1111 0000
		* 0x0f0f0f0f => 0000 1111 0000 1111 0000 1111 0000 1111
		* 32位 每4位一组 那么可以抽象成 ___ ___ ___ ___ ___ ___ ___ ___
		* (n & 0xf0f0f0f0) >>> 4 可以实现 _√_ _0_ _√_ _0_ _√_ _0_ _√_ _0_ ("_√_" 表示保留 原有4位 "_0_"表示4位全是0)
		* (n & 0x0f0f0f0f) << 4  可以实现 _0_ _√_ _0_ _√_  _0_ _√_ _0_ _√_
		* 第4步 每4位一组 一组内 前2位和 后2位交换
		* 第5步 每2位一组 一组内 前1位和 后1位交换
		*
		*
		* */
		//
		n = (n >>> 16) | (n << 16);
		n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
		n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
		n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
		n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
		return n;
	}

}
