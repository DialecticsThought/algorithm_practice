package code_for_great_offer.class50;

public class LeetCode_0568_MaximumVacationDays {
	/*
	*TODO
	* 您只能在 N 个城市之间旅行，用 0 到 N-1 的索引表示。一开始，您在索引为0的城市，而且那天是星期一。
	* 这些城市经过航班相连。这些航班用 N*N 矩阵 flights（不必定是对称的）表示，
	* flights[i][j] 表明城市i到城市j的航空状态。若是没有城市i到城市j的航班，
	* flights[i][j] = 0；不然，flights[i][j] = 1。同时，对于全部的 i，flights[i][i] = 0。
	* 您总共有 K 周（每周7天）的时间旅行。您天天最多只能乘坐一次航班，
	* 而且只能在每周的星期一上午乘坐航班。因为飞行时间很短，咱们不考虑飞行时间的影响。
	* 对于每一个城市，不一样的星期您休假天数是不一样的，给定一个 N*K 矩阵 days 表明这种限制，
	* days[i][j] 表明您在第j个星期在城市i能休假的最长天数。
	* 给定 flights 矩阵和 days 矩阵，您须要输出 K 周内能够休假的最长天数。
	* 示例 1:
	* 输入:flights = [[0,1,1],[1,0,1],[1,1,0]],
	* days = [[1,3,1],[6,0,3],[3,3,3]]
	* 输出: 12
	* 解释:
	* Ans = 6 + 3 + 3 = 12.
	* 最好的策略之一：
	* 第一个星期 : 星期一从城市0飞到城市1，玩6天，工做1天。
	* （虽然你是从城市0开始，但由于是星期一，咱们也能够飞到其余城市。）
	* 第二个星期 : 星期一从城市1飞到城市2，玩3天，工做4天。
	* 第三个星期 : 呆在城市2，玩3天，工做4天。
	* 示例 2:
	* 输入:flights = [[0,0,0],[0,0,0],[0,0,0]],
	* days = [[1,1,1],[7,7,7],[7,7,7]]
	* 输出: 3
	* 解释:
	* Ans = 1 + 1 + 1 = 3.
	* 因为没有航班可让您飞到其余城市，你必须在城市0呆整整3个星期。
	* 对于每个星期，你只有一天时间玩，剩下六天都要工做。
	* 因此最大休假天数为3.
	* 示例 3:
	* 输入:flights = [[0,1,1],[1,0,1],[1,1,0]],
	* days = [[7,0,0],[0,7,0],[0,0,7]]
	* 输出: 21
	* 解释:
	* Ans = 7 + 7 + 7 = 21
	* 最好的策略之一是：
	* 第一个星期 : 呆在城市0，玩7天。
	* 第二个星期 : 星期一从城市0飞到城市1，玩7天。
	* 第三个星期 : 星期一从城市1飞到城市2，玩7天。
	* 注意:
	* N 和 K 都是正整数，在 [1, 100] 范围内。
	* 矩阵 flights 的全部值都是 [0, 1] 范围内的整数。
	* 矩阵 days 的全部值都是 [0, 7] 范围内的整数。
	* 超过休假天数您仍能够呆在那个城市，可是在额外的日子您须要 工做 ，
	* 这些日子不会算作休假日。
	* 若是您从城市A飞往城市B并在当天休假日，
	* 这个休假会被算做是城市B的休假日。
	* 咱们不考虑飞行时间对计算休假日的影响。
	*
	*TODO
	* int[][] fly,flY[i][j] 表示城市i到城市j是否有航班 有：1  没有：0
	* int[][] day,day[i][j] 表示城市i在第j周 能休息多少天
	* */
	public static int maxVacationDays(int[][] fly, int[][] day) {
		int n = fly.length;//TODO航班的数量
		int k = day[0].length;//TODO 有k周
		// pas[i] = {a, b, c}
		// 从a、b、c能飞到i
		int[][] pass = new int[n][];
		//TODO 下面的for循环就是生成pass数组用的
		for (int i = 0; i < n; i++) {
			int s = 0;
			for (int j = 0; j < n; j++) {
				if (fly[j][i] != 0) {
					s++;
				}
			}
			pass[i] = new int[s];
			for (int j = n - 1; j >= 0; j--) {
				if (fly[j][i] != 0) {
					pass[i][--s] = j;
				}
			}
		}
		/*
		*TODO dp[i][j]: 过了0~i-1周（随意怎么过），并且第i周必须在j这座城的话，最大休假天数是多少
		* 最后是k-1周
		* 这个dp表示从上往下求 从左往右求
		* 最终把最后一行的所有数据取max即可
		* eg:
		* 假设来到dp的第4行 也就是代表第4周 有4座城市0~3
		* 那么dp[4][0]的意思：0~3周过了，不关心怎么过，只关心第4周在0号城的情况下  最大休假天数是多少
		* 那么dp[4][1]的意思：0~3周过了，不关心怎么过，只关心第4周在1号城的情况下  最大休假天数是多少
		* 那么dp[4][2]的意思：0~3周过了，不关心怎么过，只关心第4周在2号城的情况下  最大休假天数是多少
		* 那么dp[4][3]的意思：0~3周过了，不关心怎么过，只关心第4周在3号城的情况下  最大休假天数是多少
		*TODO
		* 状态转义方程
		* dp[i][j]: 过了0~i-1周（随意怎么过），并且第i周必须在j这座城的话，最大休假天数是多少？
		* 那么它的上一周 也就是上一行 应该在哪些城市过，应该在能飞到j座城的任何一个城市
		* 也就是上一行的那些满足要求的格子求 max + 第i周必须在j这座城的天数
		*TODO
		* 对于城市i，不关心能从城市i到哪些城市 而是关心哪些城市到城市i
		* eg:有个arr
		*  0 1 2
		* [0 1 1]
		* [0 0 1]
		* [1 0 0]
		* 生成结构 可用hashmap or arr 这里用了pass数组
		* <0,[2]> <1,[0]> <2,[0,1]>  k是源城市 value是可去的 目的城市
		* */
		int[][] dp = new int[k][n];
		//TODO 飞的时机，是周一早上飞，认为对时间没有影响，直接到某个城，然后过一周
		//TODO 因为一开始就是在第0周 在0号城
		dp[0][0] = day[0][0];
		for (int j = 1; j < n; j++) {
			//TODO 因为 第一开始在第0周 在0号城 不可能去其他城市 所以第0行其他格子无效
			dp[0][j] = fly[0][j] != 0 ? day[j][0] : -1;
		}
		for (int i = 1; i < k; i++) { //TODO 当前在第i周
			for (int j = 0; j < n; j++) { //TODO 当前在j号城过！
				/*
				*TODO
				* 假设已经求了第0行，现在来到第1行 代表了第1周
				* dp[1][0] = dp[0][0]+day[1][0]
				* 第1周是否可以到1号城 ，那么扫过上面一行的所有数 如果是-1，那么说明第0周到不了这个城市
				*TODO
				* 第i周，要怎么到j号城
				* 下面max的初始值，我第i-1周，就在j号城，选择不动地方，进入第i周
				* eg:
				* i-1行的dp元素是: a -1 b c -1 e d -1
				* 当前来到第i行的dp[i][5] 说明上面的元素是e
				* i-1行的元素是-1的话，根本不能用
				* e可以直接用 因为 dp[i-1][5]=e 表示第i-1周还在城市5 当前第i周 也能待在原地
				* 剩余 a b c d 那么就要看对应的城市(列)是否能飞到城市5
				* */
				int max = dp[i - 1][j];
				for (int p : pass[j]) { //TODO 枚举什么？能到j号城的城市p
					max = Math.max(max, dp[i - 1][p]);
				}
				//TODO max == -1 ==> 第i周根本无法来到j号城
				//TODO max != -1 ==> 之前的最好选择 + 第i周来到j号城过
				dp[i][j] = max != -1 ? max + day[j][i] : -1;
			}
		}
		int ans = 0;
		//TODO  枚举最后一行 取max
		for (int i = 0; i < n; i++) {
			ans = Math.max(ans, dp[k - 1][i]);
		}
		return ans;
	}

}
