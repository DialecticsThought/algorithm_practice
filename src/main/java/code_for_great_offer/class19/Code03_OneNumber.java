package code_for_great_offer.class19;

/**
 *TODO
 * 给定一个正数N，比如N = 13，在纸上把所有数都列出来如下
 * 1 2 3 4 5 6 7 8 9 10 11 12 13
 * 可以数出1这个字符出现了6次
 * 给定一个正数N，如果把1~N都列出来，返回1这个字符出现的多少次
 * eg1:
 * 12631 这是1个数
 * 1.12631取出除了最高位的数再加上1 =>  2632,2632~12631这个范围有几个1 不用递归
 * 2.剩下的1~2631 用递归求有几个1
 * 2.1 2631取出除了最高位的数再加上1 =>  632,632~2631这个范围有几个1 不用递归
 * 3.剩下的1~631 用递归求有几个1
 * 3.1 631取出除了最高位的数再加上1 =>  32,32~631这个范围有几个1 不用递归
 * 4.剩下的1~31 用递归求有几个1
 * 4.1 31取出除了最高位的数再加上1 =>  2,2~31这个范围有几个1 不用递归
 * eg:
 * 2673 这是1个数
 * 1.2673取出除了最高位的数再加上1 =>  674,674~2673这个范围有几个1 不用递归
 * 2.剩下的1~673 用递归求有几个1
 * 2.1 673取出除了最高位的数再加上1 =>  74,74~673这个范围有几个1 不用递归
 * 3.剩下的1~73 用递归求有几个1
 * 3.1 73取出除了最高位的数再加上1 =>  4,4~73这个范围有几个1 不用递归
 * 4.剩下的1~3 用递归求有几个1
 * eg2:
 * 5372
 * 5372取出除了最高位的数再加上1 ，
 * 1.求1~5372 => 求373~5372该范围上有几个1,,1~372递归
 *      把 373~5372
 * 	    拆成 373~1372  1373~2372  2373~3372  3373~4364  4373~5372 这5个部分(也是因为最高位是5，所以是5个部分)
 *      先问4个问题 千位上有几个1 百位上有几个1，十位上有几个1，个位上有几个1
 *      千位上有几个1
 *      只有1000~1999这1000个数 能贡献千位上的1
 *      百位上有几个1
 *      千 百 十 个
 *      k 1  a  b
 *      十位，个位随意变，只要固定住千位上的数
 *      千 百 十 个
 *      k a  1  b
 * 2.再求 1~372 => 求73~372该范围上有几个1 ,1~72递归
 *  把 1~372拆成 73~172  73~272  73~372
 *  百 十 个
 *  1  a  b
 *  问十位贡献多少个1 => 贡献了3*10个  a变化范围0~2
 *  百 十 个
 *  a  1  b
 *  问个位贡献多少个1 => 贡献了30个
 *  百 十 个
 *  a  b  1
 * 3.再求 1~72 => 求3~72该范围上有几个1,1~2递归
 * .....
 * 4.再求 1~2
 * eg3:
 * 1364 这个数的最高位是1 ☆☆☆☆☆☆☆☆☆☆☆
 * 1364取出除了最高位的数再加上1 ，365~1364 => 求该范围上 千位上有几个1 百位上有几个1，视为上有几个1，各位上有几个1
 * 只有1000~1364这365个数 能贡献千位上的1
 * 1.问在365~1364范围上 贡献百位上1的个数，已知365~1364范围上在千位上贡献了364个1
 * 设一个数x在365~1364范围上，这个数x满足
 * 千 百 十 个
 * 1  1  a  b
 * a和b都是在0~9上随便变动，但是如果想要百位是1，那么千位必须是1，如果千位是0(最高位是1，不可能是其他数字)，
 * 那么就是"01ab" ，不在365~1364范围上,
 * 那么也就是说a和b随意变，也就是365~1364范围上能贡献10*10个百位上的1
 * 2.问在365~1364范围上 贡献百位上1的个数，已知365~1364范围上在十位上贡献了364个1
 * 设一个数y在365~1364范围上，这个数y满足
 * 千 百 十 个
 * 1  a  1  b
 * a和b都是在0~9上随便变动， 但是如果想要十位是1，那么千位必须是1，如果千位是0(最高位是1，不可能是其他数字)，
 * 那么就是"0a1b" ，可能不在365~1364范围上
 * 设一个数z在365~1364范围上，这个数z满足
 * 千 百 十 个
 * 1  a  b  1
 * a和b都是在0~9上随便变动，但是如果想要个位是1，那么千位必须是1，如果千位是0(最高位是1，不可能是其他数字)，
 * 那么就是"0ab1" ，可能不在365~1364范围上
 * 总结：
 * 一共k位数 最高位如果是1，也就是"1rest"
 * 可以写成 1*10^k+rest
 * 求rest+1~10^k+rest范围
 * 最高位贡献rest+1个1
 * 剩下的k-1位，每一位有几个1 => 每位贡献10^(k-2)个1 表示有2个位是固定的(上面例子中是千位和某一个位),其余k-2个位的数字随意变
 * 也就是 rest+1 + (k-1)* 10^(k-2)
 * eg4:
 * 5364 这个数的最高位不是1
 * 5364取出除了最高位的数再加上1 ，365~5364 => 求该范围上有几个1
 * 千位上有几个1 百位上有几个1，十位上有几个1，个位上有几个1
 * 1.千位上有几个1
 * 	一共 1000~1999 能贡献1000个1
 * 2.百位上有几个1
 * 	针对这个问题，先把 365~5364
 * 	拆成 365~1364  1365~2364  2365~3364  3365~4364  4365~5364 这5个部分(也是因为最高位是5，所以是5个部分)
 *	在限定 百位是1的情况下 十位和个位随意的变
 *	在上面5个范围上，每一个范围都可以通过千位的调整，让每一个范围有1个数出现
 * 也就是
 * 千 百 十 个
 * ?  1  a b
 * 假设a和b都是99，也就是 "?199" 这个数，我想让这个数出现在365~1364 范围上 也就是让千位变成1即可
 * 同理我想让这个数出现在1365~2364 范围上 也就是让千位变成2即可
 * 我想让这个数出现在2365~3364 范围上 也就是让千位变成3即可
 * 我想让这个数出现在3365~4364 范围上 也就是让千位变成4即可
 * 我想让这个数出现在4365~5364 范围上 也就是让千位变成5即可
 * 3.十位上有几个1
 * 	针对这个问题，先把 365~5364
 * 	拆成 365~1364  1365~2364  2365~3364  3365~4364  4365~5364 这5个部分(也是因为最高位是5，所以是5各部分)
 *	在限定 十位是1的情况下 百位和个位随意的变
 *	在上面5个范围上，每一个范围都可以通过千位的调整，让每一个范围有1个数出现
 * 也就是
 * 千 百 十 个
 * ?  a  1 b   ?能是0,1,2,3,4
 * 假设a和b都是99，也就是 "?919" 这个数，我想让这个数出现在365~1364 范围上 也就是让千位变成0即可
 * 同理我想让这个数出现在1365~2364 范围上 也就是让千位变成1即可
 * 我想让这个数出现在2365~3364 范围上 也就是让千位变成2即可
 * 我想让这个数出现在3365~4364 范围上 也就是让千位变成3即可
 * 我想让这个数出现在4365~5364 范围上 也就是让千位变成4即可
 * 总结：
 * 一共k位数 最高位如果是x(x!=1)，也就是"xrest"
 * 可以写成 1*10^k+rest
 * 求rest+1~10^k+rest范围
 * 最高位贡献10^(k-1)个1
 * 剩下的k-1位，每一位有几个1 => 每位贡献10^(k-2)*x个1 表示先把数分成几个部分，每个部分有k-2个位的数字随意变
 * 也就是 10^(k-1) + (k-1)* 10^(k-2)*x
 *
 */
public class Code03_OneNumber {

    public static int solution1(int num) {
        if (num < 1) {
            return 0;
        }
        int count = 0;
        for (int i = 1; i != num + 1; i++) {
            count += get1Nums(i);
        }
        return count;
    }

    public static int get1Nums(int num) {
        int res = 0;
        while (num != 0) {
            if (num % 10 == 1) {
                res++;
            }
            num /= 10;
        }
        return res;
    }


    // 1 ~ num 这个范围上，画了几道1
    public static int solution2(int num) {
        if (num < 1) {
            return 0;
        }
        /**
         * num == 13625的话 len = 5位数
         */
        int len = getLenOfNum(num);
        if (len == 1) {//也就是1位数 只能表示0~9
            return 1;
        }
        /**
         * num==13625，那么 tmp1 == 10000
         * num==7872328738273，那么 tmp1==1000000000000
         */
        int tmp1 = powerBaseOf10(len - 1);
        /**
         * num最高位 =  num / tmp1
         * num==13625，那么 tmp1 == 10000 ,first = 1
         * num==7872328738273，那么 tmp1==1000000000000  ,first = 7
         */
        int first = num / tmp1;
        /**
         * 最高位有几个1
         * 如果 最高位first =1
         * eg: num =1872328738273 那么就有 872328738273+1(N % tmp1 + 1)个1
         * 如果 最高位first !=1
         *  eg: num =7872328738273 那么就有 1000000000000(tmp1)个1
         */
        int firstOneNum = first == 1 ? num % tmp1 + 1 : tmp1;
        /**
         * 除去最高位之外，剩下1的数量
         * 最高位1的话，那么10(k-2次方) * (k-1) * 1
         * 最高位first 那么10(k-2次方) * (k-1) * first
         */
        int otherOneNum = first * (len - 1) * (tmp1 / 10);
        //最高位的1的数量+其他剩余的位的1的总数量+(没有搞定的范围)递归
        return firstOneNum + otherOneNum + solution2(num % tmp1);
    }

    public static int getLenOfNum(int num) {
        int len = 0;
        while (num != 0) {
            len++;
            num /= 10;
        }
        return len;
    }

    public static int powerBaseOf10(int base) {
        return (int) Math.pow(10, base);
    }

    public static void main(String[] args) {
        int num = 50000000;
        long start1 = System.currentTimeMillis();
        System.out.println(solution1(num));
        long end1 = System.currentTimeMillis();
        System.out.println("cost time: " + (end1 - start1) + " ms");

        long start2 = System.currentTimeMillis();
        System.out.println(solution2(num));
        long end2 = System.currentTimeMillis();
        System.out.println("cost time: " + (end2 - start2) + " ms");

    }
}
