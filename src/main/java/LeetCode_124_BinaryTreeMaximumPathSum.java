/**
 * @Description
 * @Author veritas
 * @Data 2025/3/7 10:58
 */
public class LeetCode_124_BinaryTreeMaximumPathSum {
 *

    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode() {
        }

        TreeNode(int val) {
            this.val = val;
        }

        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    public int maxPathSum(TreeNode root) {
        int[] max = new int[1];
        max[0] = Integer.MIN_VALUE;

        maxGain(root,max);

        return max[0];
    }

    /**
     * <pre>
     * 方法做2件事情
     *  1.单边贡献：对于当前节点，我们希望计算出它能够作为路径的一部分，向上传递给父节点的
     *                  单边贡献=当前节点的值+max(左子树的单边贡献,右子树的单边贡献,0)
     *             当前节点会选择左右子树中能给它带来最大收益的一条边（如果某一边的收益是负的，我们就不选，直接认为收益为 0），
     *                  然后加上当前节点自身的值，形成一条连续路径向上延伸的最大收益
     *             当父节点调用这个递归函数时，它需要知道从每个子节点延伸过来的最大单边贡献，
     *                  这样父节点才能在自己的计算中，比较左右两侧哪一条边更有价值
     *                      父节点的单边贡献=父节点的值+max(左子单边贡献,右子单边贡献,0)
     *             将当前节点看作是一条路径上的“新节点”。
     *                  在父节点看来，它有两条可能的路径可以延伸过来：一条来自左边，一条来自右边。
     *                      每一条路径的值，就是子节点传上来的单边贡献。
     *
     *  2. 更新全局最大路径和（以当前节点为拐点的路径和）
     *      目的：在树中，最佳路径可能经过某个节点，然后左右分叉：
     *           也就是这个节点既利用了左子树的单边贡献，也利用了右子树的单边贡献。
     *           这种路径不能向上延伸给父节点（因为会产生分叉），但却可能在整个树中具有最大的和。
     *      如何计算：
     *          对于当前节点，可以同时取左右两个方向的贡献：
     *          turning_path_sum=node.val+max(maxGain(node.left),0)+max(maxGain(node.right),0)
     *          这里我们取左右子树的贡献，如果为负就舍弃（取 0），保证计算结果不会因为负数而变差。
     *      更新全局变量：
     *          如果turning_path_sum 比目前全局记录的最大路径和还大，就更新这个全局最大值。
     *          这种更新通常是在每个递归调用中执行的，因为任意一个节点都有可能作为“拐点”产生更大的路径和
     *  eg:
     *               (10)
     *             /    \
     *          (2)     (10)
     *          / \      /  \
     *       (20) (1)  (5)   (-25)
     *                      /    \
     *                    (3)    (4)
     *  依次从最底层开始计算。
     *  第四层（叶子节点）的计算
     *  节点 20
     *      没有左右子节点，所以：
     *          单边贡献 = 20
     *          当前路径和 = 20
     *  节点 1
     *      没有左右子节点，所以：
     *          单边贡献 = 1
     *          当前路径和 = 1
     *  节点 5
     *      没有左右子节点，所以：
     *          单边贡献 = 5
     *          当前路径和 = 5
     *  节点 3
     *      没有左右子节点，所以：
     *          单边贡献 = 3
     *          当前路径和 = 3
     *  节点 4
     *      没有左右子节点，所以：
     *          单边贡献 = 4
     *          当前路径和 = 4
     *
     *  第三层节点的计算
     *  节点 -25
     *      左子节点：节点 3，单边贡献 = 3
     *      右子节点：节点 4，单边贡献 = 4
     *      为了计算时只选正贡献，我们取：
     *          leftGain = max(3, 0) = 3
     *          rightGain = max(4, 0) = 4
     *      以 -25 为拐点的路径和 = -25 + 3 + 4 = -18
     *      向父节点传递的单边贡献 = -25 + max(3, 4) = -25 + 4 = -21
     *      全局最大更新：目前已知最大值可能是 -18，但后面可能更新更大值。
     *  节点 2（位于左子树）
     *      左子节点：节点 20，贡献 = 20
     *      右子节点：节点 1，贡献 = 1
     *      取：
     *          leftGain = max(20, 0) = 20
     *          rightGain = max(1, 0) = 1
     *      以 2 为拐点的路径和 = 2 + 20 + 1 = 23
     *      向父节点传递的单边贡献 = 2 + max(20, 1) = 2 + 20 = 22
     *      全局最大更新：更新为 23（假设最开始全局最大为负无穷）。
     *  节点 10（右子树的父节点，位于第三层）
     *      此节点有两个子：左子为节点 5，右子为节点 -25。
     *      左子节点：节点 5，贡献 = 5
     *      右子节点：节点 -25 传递的单边贡献为 -21，但由于负值，我们取 0
     *          leftGain = max(5, 0) = 5
     *          rightGain = max(-21, 0) = 0
     *          以该节点为拐点的路径和 = 10 + 5 + 0 = 15
     *          向父节点传递的单边贡献 = 10 + max(5, 0) = 10 + 5 = 15
     *      全局最大更新：当前全局最大依然是 23，因为 15 小于 23。
     *
     *  第二层节点的计算
     *  在这一层，只有两个节点：
     *      左侧节点 2（已在上一步中计算过，贡献 22）
     *      右侧节点 10（我们刚刚计算过，贡献 15）
     *
     *  第二层节点的计算
     *  在这一层，只有两个节点：
     *      左侧节点 2（已在上一步中计算过，贡献 22）
     *      右侧节点 10（我们刚刚计算过，贡献 15）
     * </pre>
     *
     * @param node
     * @param max
     * @return
     */
    private int maxGain(TreeNode node, int[] max) {
        // base case
        if (node == null) {
            return 0;
        }
        // 向左孩子要 以左孩子为尾节点的最大路径和 ，负值归零
        int leftMaxGain = Math.max(maxGain(node.left, max), 0);
        // 向右孩子要 以右孩子为尾节点的最大路径和 ，负值归零
        int rightMaxGain = Math.max(maxGain(node.right, max), 0);
        // 计算当前节点 为“拐点”的子树 的 最大路径和
        int currentPathSum = node.val + rightMaxGain + leftMaxGain;

        max[0]=Math.max(max[0], currentPathSum);
        // 向父节点 范围 以当前节点为尾节点的最大路径和 （只能选择一边）
        return node.val + Math.max(leftMaxGain, rightMaxGain);
    }
}
